/* Generated by Rae C backend (experimental) */
#include <stdint.h>
#include <string.h>
#ifndef RAE_HAS_RAYLIB
#define RAE_HAS_RAYLIB
#endif
#include <raylib.h>
#include "rae_runtime.h"

typedef enum {
  GameState_Menu,
  GameState_Playing,
  GameState_Paused,
  GameState_GameOver
} GameState;

typedef enum {
  TetrominoKind_I,
  TetrominoKind_J,
  TetrominoKind_L,
  TetrominoKind_O,
  TetrominoKind_S,
  TetrominoKind_T,
  TetrominoKind_Z
} TetrominoKind;

typedef struct {
  RaeAny* data;
  int64_t length;
  int64_t capacity;
} List;

typedef struct {
  const char* k;
  RaeAny value;
  int8_t occupied;
} StringMapEntry;

typedef struct {
  StringMapEntry* data;
  int64_t length;
  int64_t capacity;
} StringMap;

typedef struct {
  int64_t k;
  RaeAny value;
  int8_t occupied;
} IntMapEntry;

typedef struct {
  IntMapEntry* data;
  int64_t length;
  int64_t capacity;
} IntMap;

typedef struct {
  int64_t x;
  int64_t y;
} Pos;

typedef struct {
  TetrominoKind kind;
  Pos pos;
  int64_t rotation;
} Piece;

typedef struct {
  GameState state;
  List grid;
  int64_t width;
  int64_t height;
  Piece currentPiece;
  int64_t score;
  int64_t lines;
  int64_t level;
  int64_t moveTimer;
  int64_t moveDelay;
} Game;

extern int64_t rae_ext_nextTick(void);
extern int64_t rae_ext_nowMs(void);
extern void rae_ext_rae_sleep(int64_t ms);
extern double rae_ext_rae_int_to_float(int64_t i);
RAE_UNUSED static double rae_toFloat_Int_(int64_t this);
RAE_UNUSED static List rae_createList_Int_(int64_t initialCap);
RAE_UNUSED static void rae_grow_List_(List* this);
RAE_UNUSED static void rae_add_List_T_(List* this, RaeAny value);
RAE_UNUSED static RaeAny rae_get_List_Int_(List* this, int64_t index);
RAE_UNUSED static void rae_set_List_Int_T_(List* this, int64_t index, RaeAny value);
RAE_UNUSED static void rae_insert_List_Int_T_(List* this, int64_t index, RaeAny value);
RAE_UNUSED static RaeAny rae_pop_List_(List* this);
RAE_UNUSED static void rae_remove_List_Int_(List* this, int64_t index);
RAE_UNUSED static void rae_clear_List_(List* this);
RAE_UNUSED static int64_t rae_length_List_(List* this);
RAE_UNUSED static void rae_swap_List_Int_Int_(List* this, int64_t i, int64_t j);
RAE_UNUSED static void rae_free_List_(List* this);
extern int64_t rae_ext_rae_str_hash(const char* s);
extern int8_t rae_ext_rae_str_eq(const char* a, const char* b);
RAE_UNUSED static StringMap rae_createStringMap_Int_(int64_t initialCap);
RAE_UNUSED static void rae_set_StringMap_String_V_(StringMap* this, const char* k, RaeAny value);
RAE_UNUSED static RaeAny rae_get_StringMap_String_(StringMap* this, const char* k);
RAE_UNUSED static int8_t rae_has_StringMap_String_(StringMap* this, const char* k);
RAE_UNUSED static void rae_growStringMap_StringMap_(StringMap* this);
RAE_UNUSED static void rae_free_StringMap_(StringMap* this);
RAE_UNUSED static IntMap rae_createIntMap_Int_(int64_t initialCap);
RAE_UNUSED static void rae_set_IntMap_Int_V_(IntMap* this, int64_t k, RaeAny value);
RAE_UNUSED static RaeAny rae_get_IntMap_Int_(IntMap* this, int64_t k);
RAE_UNUSED static int8_t rae_has_IntMap_Int_(IntMap* this, int64_t k);
RAE_UNUSED static void rae_growIntMap_IntMap_(IntMap* this);
RAE_UNUSED static void rae_free_IntMap_(IntMap* this);
extern void rae_ext_rae_seed(int64_t n);
extern double rae_ext_rae_random(void);
extern int64_t rae_ext_rae_random_int(int64_t min, int64_t max);
RAE_UNUSED static void rae_seed_Int_(int64_t n);
RAE_UNUSED static double rae_random_(void);
RAE_UNUSED static int64_t rae_random_Int_Int_(int64_t min, int64_t max);
RAE_UNUSED static int64_t rae_abs_Int_(int64_t n);
RAE_UNUSED static double rae_abs_Float_(double n);
RAE_UNUSED static int64_t rae_min_Int_Int_(int64_t a, int64_t b);
RAE_UNUSED static int64_t rae_max_Int_Int_(int64_t a, int64_t b);
RAE_UNUSED static int64_t rae_clamp_Int_Int_Int_(int64_t val, int64_t low, int64_t high);
RAE_UNUSED static double rae_lerp_Float_Float_Float_(double a, double b, double t);
RAE_UNUSED static double rae_randomFloat_Float_Float_(double min, double max);
extern int64_t rae_ext_rae_str_len(const char* s);
extern int64_t rae_ext_rae_str_compare(const char* a, const char* b);
extern const char* rae_ext_rae_str_concat(const char* a, const char* b);
extern const char* rae_ext_rae_str_sub(const char* s, int64_t start, int64_t len);
extern int8_t rae_ext_rae_str_contains(const char* s, const char* sub);
extern double rae_ext_rae_str_to_f64(const char* s);
extern int64_t rae_ext_rae_str_to_i64(const char* s);
RAE_UNUSED static int64_t rae_length_String_(const char* this);
RAE_UNUSED static int64_t rae_compare_String_String_(const char* this, const char* other);
RAE_UNUSED static int8_t rae_equals_String_String_(const char* this, const char* other);
RAE_UNUSED static int64_t rae_hash_String_(const char* this);
RAE_UNUSED static const char* rae_concat_String_String_(const char* this, const char* other);
RAE_UNUSED static const char* rae_sub_String_Int_Int_(const char* this, int64_t start, int64_t len);
RAE_UNUSED static int8_t rae_contains_String_String_(const char* this, const char* sub);
RAE_UNUSED static double rae_toFloat_String_(const char* this);
RAE_UNUSED static int64_t rae_toInt_String_(const char* this);
extern void rae_ext_setConfigFlags(int64_t flags);
RAE_UNUSED int64_t rae_ext_windowShouldClose(void) {
  return WindowShouldClose();
}

RAE_UNUSED void rae_ext_closeWindow(void) {
  CloseWindow();
}

RAE_UNUSED void rae_ext_beginDrawing(void) {
  BeginDrawing();
}

RAE_UNUSED void rae_ext_endDrawing(void) {
  EndDrawing();
}

RAE_UNUSED void rae_ext_clearBackground(Color color) {
  ClearBackground((Color){ (unsigned char)color.r, (unsigned char)color.g, (unsigned char)color.b, (unsigned char)color.a });
}

RAE_UNUSED void rae_ext_drawRectangle(double x, double y, double width, double height, Color color) {
  DrawRectangle((float)x, (float)y, (float)width, (float)height, (Color){ (unsigned char)color.r, (unsigned char)color.g, (unsigned char)color.b, (unsigned char)color.a });
}

RAE_UNUSED void rae_ext_drawCircle(double x, double y, double radius, Color color) {
  DrawCircle((float)x, (float)y, (float)radius, (Color){ (unsigned char)color.r, (unsigned char)color.g, (unsigned char)color.b, (unsigned char)color.a });
}

RAE_UNUSED void rae_ext_drawText(const char* text, double x, double y, double fontSize, Color color) {
  DrawText(text, (float)x, (float)y, (float)fontSize, (Color){ (unsigned char)color.r, (unsigned char)color.g, (unsigned char)color.b, (unsigned char)color.a });
}

RAE_UNUSED void rae_ext_drawCube(Vector3 pos, double width, double height, double length, Color color) {
  DrawCube((Vector3){ (float)pos.x, (float)pos.y, (float)pos.z }, (float)width, (float)height, (float)length, (Color){ (unsigned char)color.r, (unsigned char)color.g, (unsigned char)color.b, (unsigned char)color.a });
}

extern void rae_ext_drawCubeWires(Vector3 pos, double width, double height, double length, Color color);
extern void rae_ext_drawSphere(Vector3 centerPos, double radius, Color color);
RAE_UNUSED void rae_ext_drawCylinder(Vector3 position, double radiusTop, double radiusBottom, double height, int64_t slices, Color color) {
  DrawCylinder((Vector3){ (float)position.x, (float)position.y, (float)position.z }, (float)radiusTop, (float)radiusBottom, (float)height, (int)slices, (Color){ (unsigned char)color.r, (unsigned char)color.g, (unsigned char)color.b, (unsigned char)color.a });
}

RAE_UNUSED void rae_ext_drawGrid(int64_t slices, double spacing) {
  DrawGrid((int)slices, (float)spacing);
}

RAE_UNUSED void rae_ext_beginMode3D(Camera3D camera) {
  BeginMode3D((Camera3D){ .position = (Vector3){ (float)camera.position.x, (float)camera.position.y, (float)camera.position.z }, .target = (Vector3){ (float)camera.target.x, (float)camera.target.y, (float)camera.target.z }, .up = (Vector3){ (float)camera.up.x, (float)camera.up.y, (float)camera.up.z }, .fovy = (float)camera.fovy, .projection = (int)camera.projection });
}

RAE_UNUSED void rae_ext_endMode3D(void) {
  EndMode3D();
}

RAE_UNUSED void rae_ext_setTargetFPS(int64_t fps) {
  SetTargetFPS((int)fps);
}

RAE_UNUSED int64_t rae_ext_isKeyDown(int64_t key) {
  return IsKeyDown((int)key);
}

RAE_UNUSED int64_t rae_ext_isKeyPressed(int64_t key) {
  return IsKeyPressed((int)key);
}

extern double rae_ext_getTime(void);
extern Color rae_ext_colorFromHSV(double hue, double saturation, double value);
RAE_UNUSED static Color rae_getModernColor_Int_(int64_t index);
RAE_UNUSED static int64_t rae_getKindId_TetrominoKind_(TetrominoKind kind);
RAE_UNUSED static int64_t rae_isOccupied_Game_Int_Int_(Game* g, int64_t x, int64_t y);
RAE_UNUSED static int64_t rae_getShapeCell_TetrominoKind_Int_Int_Int_(TetrominoKind kind, int64_t rot, int64_t px, int64_t py);
RAE_UNUSED static int64_t rae_canMove_Game_Int_Int_Int_(Game* g, int64_t dx, int64_t dy, int64_t dr);
RAE_UNUSED static void rae_lockPiece_Game_(Game* g);
RAE_UNUSED static void rae_checkLines_Game_(Game* g);
RAE_UNUSED static void rae_spawnPiece_Game_(Game* g);
RAE_UNUSED static void rae_initGame_Game_(Game* g);
RAE_UNUSED static void rae_draw_Game_(Game* g);

RAE_UNUSED static double rae_toFloat_Int_(int64_t this) {
  return rae_ext_rae_int_to_float(this);
}

RAE_UNUSED static List rae_createList_Int_(int64_t initialCap) {
  return (List){ .data = rae_ext_rae_buf_alloc(initialCap, sizeof(RaeAny)), .length = 0, .capacity = initialCap };
}

RAE_UNUSED static void rae_grow_List_(List* this) {
  int64_t newCap = this->capacity * 2;
  if (newCap == 0) {
  newCap = 4;
  }
  RaeAny* newData = rae_ext_rae_buf_alloc(newCap, sizeof(RaeAny));
  rae_ext_rae_buf_copy(this->data, 0, newData, 0, this->length, sizeof(RaeAny));
  rae_ext_rae_buf_free(this->data);
  this->data = newData;
  this->capacity = newCap;
}

RAE_UNUSED static void rae_add_List_T_(List* this, RaeAny value) {
  if (this->length == this->capacity) {
  rae_grow_List_(this);
  }
  ((RaeAny*)(this->data))[this->length] = rae_any(value);
  this->length = this->length + 1;
}

RAE_UNUSED static RaeAny rae_get_List_Int_(List* this, int64_t index) {
  if (index < 0 || index >= this->length) {
  return rae_any_none();
  }
  return rae_any(((RaeAny*)(this->data))[index]);
}

RAE_UNUSED static void rae_set_List_Int_T_(List* this, int64_t index, RaeAny value) {
  if (index < 0 || index >= this->length) {
  return;
  }
  ((RaeAny*)(this->data))[index] = rae_any(value);
}

RAE_UNUSED static void rae_insert_List_Int_T_(List* this, int64_t index, RaeAny value) {
  if (index < 0 || index > this->length) {
  return;
  }
  if (this->length == this->capacity) {
  rae_grow_List_(this);
  }
  if (index < this->length) {
  rae_ext_rae_buf_copy(this->data, index, this->data, index + 1, this->length - index, sizeof(RaeAny));
  }
  ((RaeAny*)(this->data))[index] = rae_any(value);
  this->length = this->length + 1;
}

RAE_UNUSED static RaeAny rae_pop_List_(List* this) {
  if (this->length == 0) {
  return rae_any_none();
  }
  RaeAny val = ((RaeAny*)(this->data))[this->length - 1];
  this->length = this->length - 1;
  return rae_any(val);
}

RAE_UNUSED static void rae_remove_List_Int_(List* this, int64_t index) {
  if (index < 0 || index >= this->length) {
  return;
  }
  if (index < this->length - 1) {
  rae_ext_rae_buf_copy(this->data, index + 1, this->data, index, this->length - index - 1, sizeof(RaeAny));
  }
  this->length = this->length - 1;
}

RAE_UNUSED static void rae_clear_List_(List* this) {
  this->length = 0;
}

RAE_UNUSED static int64_t rae_length_List_(List* this) {
  return this->length;
}

RAE_UNUSED static void rae_swap_List_Int_Int_(List* this, int64_t i, int64_t j) {
  RaeAny temp = ((RaeAny*)(this->data))[i];
  ((RaeAny*)(this->data))[i] = rae_any(((RaeAny*)(this->data))[j]);
  ((RaeAny*)(this->data))[j] = rae_any(temp);
}

RAE_UNUSED static void rae_free_List_(List* this) {
  rae_ext_rae_buf_free(this->data);
  this->length = 0;
  this->capacity = 0;
}

RAE_UNUSED static StringMap rae_createStringMap_Int_(int64_t initialCap) {
  return (StringMap){ .data = rae_ext_rae_buf_alloc(initialCap, sizeof(RaeAny)), .length = 0, .capacity = initialCap };
}

RAE_UNUSED static void rae_set_StringMap_String_V_(StringMap* this, const char* k, RaeAny value) {
  if (this->capacity == 0) {
  this->capacity = 8;
  this->data = rae_ext_rae_buf_alloc(this->capacity, sizeof(RaeAny));
  }
  if (this->length * 2 > this->capacity) {
  rae_growStringMap_StringMap_(this);
  }
  int64_t h = rae_ext_rae_str_hash(k);
  int64_t idx = h % this->capacity;
  if (idx < 0) {
  idx = (-idx);
  }
  {
  while (1) {
  StringMapEntry entry = ((StringMapEntry*)(this->data))[idx];
  if ((!(entry.occupied))) {
  ((StringMapEntry*)(this->data))[idx] = (StringMapEntry){ .k = k, .value = value, .occupied = 1 };
  this->length = this->length + 1;
  return;
  }
  if (rae_ext_rae_str_eq(entry.k, k)) {
  entry.value = value;
  ((StringMapEntry*)(this->data))[idx] = entry;
  return;
  }
  idx = (idx + 1) % this->capacity;
  }
  }
}

RAE_UNUSED static RaeAny rae_get_StringMap_String_(StringMap* this, const char* k) {
  if (this->capacity == 0) {
  return rae_any_none();
  }
  int64_t h = rae_ext_rae_str_hash(k);
  int64_t idx = h % this->capacity;
  if (idx < 0) {
  idx = (-idx);
  }
  int64_t startIdx = idx;
  {
  while (1) {
  StringMapEntry entry = ((StringMapEntry*)(this->data))[idx];
  if ((!(entry.occupied))) {
  return rae_any_none();
  }
  if (rae_ext_rae_str_eq(entry.k, k)) {
  return rae_any(entry.value);
  }
  idx = (idx + 1) % this->capacity;
  if (idx == startIdx) {
  return rae_any_none();
  }
  }
  }
}

RAE_UNUSED static int8_t rae_has_StringMap_String_(StringMap* this, const char* k) {
  RaeAny __match0 = rae_any(((RaeAny)(rae_get_StringMap_String_(this, k))));
  if (__match0.type == RAE_TYPE_NONE) {
  return 0;
  } else {
  return 1;
  }
}

RAE_UNUSED static void rae_growStringMap_StringMap_(StringMap* this) {
  int64_t oldCap = this->capacity;
  StringMapEntry* oldData = this->data;
  this->capacity = oldCap * 2;
  if (this->capacity == 0) {
  this->capacity = 8;
  }
  this->data = rae_ext_rae_buf_alloc(this->capacity, sizeof(RaeAny));
  this->length = 0;
  int64_t i = 0;
  {
  while (i < oldCap) {
  StringMapEntry entry = ((StringMapEntry*)(oldData))[i];
  if (entry.occupied) {
  rae_set_StringMap_String_V_(this, entry.k, rae_any(entry.value));
  }
  i = i + 1;
  }
  }
  rae_ext_rae_buf_free(oldData);
}

RAE_UNUSED static void rae_free_StringMap_(StringMap* this) {
  rae_ext_rae_buf_free(this->data);
  this->length = 0;
  this->capacity = 0;
}

RAE_UNUSED static IntMap rae_createIntMap_Int_(int64_t initialCap) {
  return (IntMap){ .data = rae_ext_rae_buf_alloc(initialCap, sizeof(RaeAny)), .length = 0, .capacity = initialCap };
}

RAE_UNUSED static void rae_set_IntMap_Int_V_(IntMap* this, int64_t k, RaeAny value) {
  if (this->capacity == 0) {
  this->capacity = 8;
  this->data = rae_ext_rae_buf_alloc(this->capacity, sizeof(RaeAny));
  }
  if (this->length * 2 > this->capacity) {
  rae_growIntMap_IntMap_(this);
  }
  int64_t h = k;
  int64_t idx = h % this->capacity;
  if (idx < 0) {
  idx = (-idx);
  }
  {
  while (1) {
  IntMapEntry entry = ((IntMapEntry*)(this->data))[idx];
  if ((!(entry.occupied))) {
  ((IntMapEntry*)(this->data))[idx] = (IntMapEntry){ .k = k, .value = value, .occupied = 1 };
  this->length = this->length + 1;
  return;
  }
  if (entry.k == k) {
  entry.value = value;
  ((IntMapEntry*)(this->data))[idx] = entry;
  return;
  }
  idx = (idx + 1) % this->capacity;
  }
  }
}

RAE_UNUSED static RaeAny rae_get_IntMap_Int_(IntMap* this, int64_t k) {
  if (this->capacity == 0) {
  return rae_any_none();
  }
  int64_t h = k;
  int64_t idx = h % this->capacity;
  if (idx < 0) {
  idx = (-idx);
  }
  int64_t startIdx = idx;
  {
  while (1) {
  IntMapEntry entry = ((IntMapEntry*)(this->data))[idx];
  if ((!(entry.occupied))) {
  return rae_any_none();
  }
  if (entry.k == k) {
  return rae_any(entry.value);
  }
  idx = (idx + 1) % this->capacity;
  if (idx == startIdx) {
  return rae_any_none();
  }
  }
  }
}

RAE_UNUSED static int8_t rae_has_IntMap_Int_(IntMap* this, int64_t k) {
  RaeAny __match0 = rae_any(((RaeAny)(rae_get_IntMap_Int_(this, k))));
  if (__match0.type == RAE_TYPE_NONE) {
  return 0;
  } else {
  return 1;
  }
}

RAE_UNUSED static void rae_growIntMap_IntMap_(IntMap* this) {
  int64_t oldCap = this->capacity;
  IntMapEntry* oldData = this->data;
  this->capacity = oldCap * 2;
  if (this->capacity == 0) {
  this->capacity = 8;
  }
  this->data = rae_ext_rae_buf_alloc(this->capacity, sizeof(RaeAny));
  this->length = 0;
  int64_t i = 0;
  {
  while (i < oldCap) {
  IntMapEntry entry = ((IntMapEntry*)(oldData))[i];
  if (entry.occupied) {
  rae_set_IntMap_Int_V_(this, entry.k, rae_any(entry.value));
  }
  i = i + 1;
  }
  }
  rae_ext_rae_buf_free(oldData);
}

RAE_UNUSED static void rae_free_IntMap_(IntMap* this) {
  rae_ext_rae_buf_free(this->data);
  this->length = 0;
  this->capacity = 0;
}

RAE_UNUSED static void rae_seed_Int_(int64_t n) {
  rae_ext_rae_seed(n);
}

RAE_UNUSED static double rae_random_(void) {
  return rae_ext_rae_random();
}

RAE_UNUSED static int64_t rae_random_Int_Int_(int64_t min, int64_t max) {
  return rae_ext_rae_random_int(min, max);
}

RAE_UNUSED static int64_t rae_abs_Int_(int64_t n) {
  if (n < 0) {
  return (-n);
  }
  return n;
}

RAE_UNUSED static double rae_abs_Float_(double n) {
  if (n < 0.0) {
  return (-n);
  }
  return n;
}

RAE_UNUSED static int64_t rae_min_Int_Int_(int64_t a, int64_t b) {
  if (a < b) {
  return a;
  }
  return b;
}

RAE_UNUSED static int64_t rae_max_Int_Int_(int64_t a, int64_t b) {
  if (a > b) {
  return a;
  }
  return b;
}

RAE_UNUSED static int64_t rae_clamp_Int_Int_Int_(int64_t val, int64_t low, int64_t high) {
  if (val < low) {
  return low;
  }
  if (val > high) {
  return high;
  }
  return val;
}

RAE_UNUSED static double rae_lerp_Float_Float_Float_(double a, double b, double t) {
  return a + (b - a) * t;
}

RAE_UNUSED static double rae_randomFloat_Float_Float_(double min, double max) {
  return min + rae_ext_rae_random() * (max - min);
}

RAE_UNUSED static int64_t rae_length_String_(const char* this) {
  return rae_ext_rae_str_len(this);
}

RAE_UNUSED static int64_t rae_compare_String_String_(const char* this, const char* other) {
  return rae_ext_rae_str_compare(this, other);
}

RAE_UNUSED static int8_t rae_equals_String_String_(const char* this, const char* other) {
  return rae_ext_rae_str_eq(this, other);
}

RAE_UNUSED static int64_t rae_hash_String_(const char* this) {
  return rae_ext_rae_str_hash(this);
}

RAE_UNUSED static const char* rae_concat_String_String_(const char* this, const char* other) {
  return rae_ext_rae_str_concat(this, other);
}

RAE_UNUSED static const char* rae_sub_String_Int_Int_(const char* this, int64_t start, int64_t len) {
  return rae_ext_rae_str_sub(this, start, len);
}

RAE_UNUSED static int8_t rae_contains_String_String_(const char* this, const char* sub) {
  return rae_ext_rae_str_contains(this, sub);
}

RAE_UNUSED static double rae_toFloat_String_(const char* this) {
  return rae_ext_rae_str_to_f64(this);
}

RAE_UNUSED static int64_t rae_toInt_String_(const char* this) {
  return rae_ext_rae_str_to_i64(this);
}

RAE_UNUSED static Color rae_getModernColor_Int_(int64_t index) {
  if (index == 1) {
  return (Color){ .r = 100, .g = 230, .b = 255, .a = 255 };
  }
  if (index == 2) {
  return (Color){ .r = 120, .g = 160, .b = 255, .a = 255 };
  }
  if (index == 3) {
  return (Color){ .r = 255, .g = 180, .b = 120, .a = 255 };
  }
  if (index == 4) {
  return (Color){ .r = 255, .g = 230, .b = 120, .a = 255 };
  }
  if (index == 5) {
  return (Color){ .r = 120, .g = 255, .b = 160, .a = 255 };
  }
  if (index == 6) {
  return (Color){ .r = 200, .g = 160, .b = 255, .a = 255 };
  }
  if (index == 7) {
  return (Color){ .r = 255, .g = 120, .b = 140, .a = 255 };
  }
  return (Color){ .r = 40, .g = 40, .b = 50, .a = 255 };
}

RAE_UNUSED static int64_t rae_getKindId_TetrominoKind_(TetrominoKind kind) {
  if (kind == TetrominoKind_I) {
  return 1;
  }
  if (kind == TetrominoKind_J) {
  return 2;
  }
  if (kind == TetrominoKind_L) {
  return 3;
  }
  if (kind == TetrominoKind_O) {
  return 4;
  }
  if (kind == TetrominoKind_S) {
  return 5;
  }
  if (kind == TetrominoKind_T) {
  return 6;
  }
  return 7;
}

RAE_UNUSED static int64_t rae_isOccupied_Game_Int_Int_(Game* g, int64_t x, int64_t y) {
  if (x < 0 || x >= g->width || y >= g->height) {
  return 1;
  }
  if (y < 0) {
  return 0;
  }
  if (((int64_t)(rae_get_List_Int_(&(g->grid), y * g->width + x)).as.i) > 0) {
  return 1;
  }
  return 0;
}

RAE_UNUSED static int64_t rae_getShapeCell_TetrominoKind_Int_Int_Int_(TetrominoKind kind, int64_t rot, int64_t px, int64_t py) {
  if (kind == TetrominoKind_I) {
  if (rot == 0 || rot == 2) {
  if (px == 1) {
  return 1;
  }
  } else {
  if (py == 1) {
  return 1;
  }
  }
  } else {
  if (kind == TetrominoKind_J) {
  if (rot == 0) {
  if (px == 1 && py >= 0 && py <= 2 || px == 0 && py == 2) {
  return 1;
  }
  } else {
  if (rot == 1) {
  if (py == 1 && px >= 0 && px <= 2 || px == 0 && py == 0) {
  return 1;
  }
  } else {
  if (rot == 2) {
  if (px == 1 && py >= 0 && py <= 2 || px == 2 && py == 0) {
  return 1;
  }
  } else {
  if (rot == 3) {
  if (py == 1 && px >= 0 && px <= 2 || px == 2 && py == 2) {
  return 1;
  }
  }
  }
  }
  }
  } else {
  if (kind == TetrominoKind_L) {
  if (rot == 0) {
  if (px == 1 && py >= 0 && py <= 2 || px == 2 && py == 2) {
  return 1;
  }
  } else {
  if (rot == 1) {
  if (py == 1 && px >= 0 && px <= 2 || px == 0 && py == 2) {
  return 1;
  }
  } else {
  if (rot == 2) {
  if (px == 1 && py >= 0 && py <= 2 || px == 0 && py == 0) {
  return 1;
  }
  } else {
  if (rot == 3) {
  if (py == 1 && px >= 0 && px <= 2 || px == 2 && py == 0) {
  return 1;
  }
  }
  }
  }
  }
  } else {
  if (kind == TetrominoKind_O) {
  if (px >= 1 && px <= 2 && py >= 1 && py <= 2) {
  return 1;
  }
  } else {
  if (kind == TetrominoKind_S) {
  if (rot == 0 || rot == 2) {
  if (py == 1 && px >= 1 && px <= 2 || py == 2 && px >= 0 && px <= 1) {
  return 1;
  }
  } else {
  if (px == 1 && py >= 0 && py <= 1 || px == 2 && py >= 1 && py <= 2) {
  return 1;
  }
  }
  } else {
  if (kind == TetrominoKind_T) {
  if (rot == 0) {
  if (py == 1 && px >= 0 && px <= 2 || px == 1 && py == 0) {
  return 1;
  }
  } else {
  if (rot == 1) {
  if (px == 1 && py >= 0 && py <= 2 || px == 2 && py == 1) {
  return 1;
  }
  } else {
  if (rot == 2) {
  if (py == 1 && px >= 0 && px <= 2 || px == 1 && py == 2) {
  return 1;
  }
  } else {
  if (rot == 3) {
  if (px == 1 && py >= 0 && py <= 2 || px == 0 && py == 1) {
  return 1;
  }
  }
  }
  }
  }
  } else {
  if (kind == TetrominoKind_Z) {
  if (rot == 0 || rot == 2) {
  if (py == 1 && px >= 0 && px <= 1 || py == 2 && px >= 1 && px <= 2) {
  return 1;
  }
  } else {
  if (px == 1 && py >= 1 && py <= 2 || px == 2 && py >= 0 && py <= 1) {
  return 1;
  }
  }
  }
  }
  }
  }
  }
  }
  }
  return 0;
}

RAE_UNUSED static int64_t rae_canMove_Game_Int_Int_Int_(Game* g, int64_t dx, int64_t dy, int64_t dr) {
  Piece* cp = &(g->currentPiece);
  Pos* pos = &(cp->pos);
  int64_t newX = pos->x + dx;
  int64_t newY = pos->y + dy;
  int64_t newRot = (cp->rotation + dr) % 4;
  if (newRot < 0) {
  newRot = newRot + 4;
  }
  int64_t py = 0;
  {
  while (py < 4) {
  int64_t px = 0;
  {
  while (px < 4) {
  if (rae_getShapeCell_TetrominoKind_Int_Int_Int_(cp->kind, newRot, px, py) == 1) {
  if (rae_isOccupied_Game_Int_Int_(g, newX + px, newY + py) == 1) {
  return 0;
  }
  }
  px = px + 1;
  }
  }
  py = py + 1;
  }
  }
  return 1;
}

RAE_UNUSED static void rae_lockPiece_Game_(Game* g) {
  Piece* cp = &(g->currentPiece);
  Pos* pos = &(cp->pos);
  List* grid = &(g->grid);
  int64_t kindId = rae_getKindId_TetrominoKind_(cp->kind);
  int64_t py = 0;
  {
  while (py < 4) {
  int64_t px = 0;
  {
  while (px < 4) {
  if (rae_getShapeCell_TetrominoKind_Int_Int_Int_(cp->kind, cp->rotation, px, py) == 1) {
  int64_t gx = pos->x + px;
  int64_t gy = pos->y + py;
  if (gy >= 0 && gy < g->height) {
  rae_set_List_Int_T_(grid, gy * g->width + gx, rae_any(kindId));
  }
  }
  px = px + 1;
  }
  }
  py = py + 1;
  }
  }
}

RAE_UNUSED static void rae_checkLines_Game_(Game* g) {
  List* grid = &(g->grid);
  int64_t linesCleared = 0;
  int64_t y = g->height - 1;
  {
  while (y >= 0) {
  int64_t full = 1;
  int64_t x = 0;
  {
  while (x < g->width) {
  if (((int64_t)(rae_get_List_Int_(grid, y * g->width + x)).as.i) == 0) {
  full = 0;
  }
  x = x + 1;
  }
  }
  if (full == 1) {
  linesCleared = linesCleared + 1;
  int64_t ty = y;
  {
  while (ty > 0) {
  int64_t tx = 0;
  {
  while (tx < g->width) {
  rae_set_List_Int_T_(grid, ty * g->width + tx, rae_any(((int64_t)(rae_get_List_Int_(grid, (ty - 1) * g->width + tx)).as.i)));
  tx = tx + 1;
  }
  }
  ty = ty - 1;
  }
  }
  int64_t tx = 0;
  {
  while (tx < g->width) {
  rae_set_List_Int_T_(grid, tx, rae_any(0));
  tx = tx + 1;
  }
  }
  y = y + 1;
  }
  y = y - 1;
  }
  }
  if (linesCleared > 0) {
  g->lines = g->lines + linesCleared;
  g->score = g->score + linesCleared * 100 * g->level;
  int64_t newLevel = g->lines / 10 + 1;
  if (newLevel > 10) {
  newLevel = 10;
  }
  if (newLevel > g->level) {
  g->level = newLevel;
  g->moveDelay = 32 - g->level * 3;
  if (g->moveDelay < 2) {
  g->moveDelay = 2;
  }
  }
  }
}

RAE_UNUSED static void rae_spawnPiece_Game_(Game* g) {
  Piece* cp = &(g->currentPiece);
  int64_t k = rae_random_Int_Int_(0, 6);
  if (k == 0) {
  cp->kind = TetrominoKind_I;
  } else {
  if (k == 1) {
  cp->kind = TetrominoKind_J;
  } else {
  if (k == 2) {
  cp->kind = TetrominoKind_L;
  } else {
  if (k == 3) {
  cp->kind = TetrominoKind_O;
  } else {
  if (k == 4) {
  cp->kind = TetrominoKind_S;
  } else {
  if (k == 5) {
  cp->kind = TetrominoKind_T;
  } else {
  cp->kind = TetrominoKind_Z;
  }
  }
  }
  }
  }
  }
  Pos* pos = &(cp->pos);
  pos->x = g->width / 2 - 2;
  pos->y = (-1);
  cp->rotation = 0;
  if (rae_canMove_Game_Int_Int_Int_(g, 0, 0, 0) == 0) {
  g->state = GameState_GameOver;
  }
}

RAE_UNUSED static void rae_initGame_Game_(Game* g) {
  g->state = GameState_Playing;
  g->width = 10;
  g->height = 20;
  g->score = 0;
  g->lines = 0;
  g->level = 1;
  g->moveTimer = 0;
  g->moveDelay = 30;
  int64_t i = 0;
  List* grid = &(g->grid);
  rae_clear_List_(grid);
  {
  while (i < g->width * g->height) {
  rae_add_List_T_(grid, rae_any(0));
  i = i + 1;
  }
  }
  rae_spawnPiece_Game_(g);
}

RAE_UNUSED static void rae_draw_Game_(Game* g) {
  rae_ext_beginDrawing();
  rae_ext_clearBackground((Color){ .r = 30, .g = 30, .b = 40, .a = 255 });
  double offsetX = 100.0;
  double offsetY = 50.0;
  double cellSize = 20.0;
  rae_drawRectangleLines_(offsetX - 2.0, offsetY - 2.0, rae_toFloat_Int_(g->width) * cellSize + 4.0, rae_toFloat_Int_(g->height) * cellSize + 4.0, { .r = 180, .g = 180, .b = 255, .a = 255 });
  int64_t y = 0;
  {
  while (y < g->height) {
  int64_t x = 0;
  {
  while (x < g->width) {
  int64_t val = ((int64_t)(rae_get_List_Int_(&(g->grid), y * g->width + x)).as.i);
  if (val > 0) {
  rae_ext_drawRectangle(rae_toFloat_Int_(x) * cellSize + offsetX, rae_toFloat_Int_(y) * cellSize + offsetY, cellSize - 1.0, cellSize - 1.0, rae_getModernColor_Int_(val));
  }
  x = x + 1;
  }
  }
  y = y + 1;
  }
  }
  Piece* cp = &(g->currentPiece);
  Pos* pos = &(cp->pos);
  int64_t kindId = rae_getKindId_TetrominoKind_(cp->kind);
  int64_t py = 0;
  {
  while (py < 4) {
  int64_t px = 0;
  {
  while (px < 4) {
  if (rae_getShapeCell_TetrominoKind_Int_Int_Int_(cp->kind, cp->rotation, px, py) == 1) {
  rae_ext_drawRectangle(rae_toFloat_Int_(pos->x + px) * cellSize + offsetX, rae_toFloat_Int_(pos->y + py) * cellSize + offsetY, cellSize - 1.0, cellSize - 1.0, rae_getModernColor_Int_(kindId));
  }
  px = px + 1;
  }
  }
  py = py + 1;
  }
  }
  rae_ext_drawText(rae_ext_rae_str_concat(rae_ext_rae_str_concat("SCORE: ", rae_ext_rae_str(g->score)), ""), 10.0, 10.0, 20.0, (Color){ .r = 255, .g = 200, .b = 200, .a = 255 });
  rae_ext_drawText(rae_ext_rae_str_concat(rae_ext_rae_str_concat("LEVEL: ", rae_ext_rae_str(g->level)), ""), 10.0, 35.0, 20.0, (Color){ .r = 200, .g = 255, .b = 200, .a = 255 });
  rae_ext_drawText(rae_ext_rae_str_concat(rae_ext_rae_str_concat("LINES: ", rae_ext_rae_str(g->lines)), ""), 10.0, 60.0, 20.0, (Color){ .r = 200, .g = 200, .b = 255, .a = 255 });
  if (g->state == GameState_Paused) {
  rae_ext_drawText("PAUSED", 140.0, 200.0, 40.0, (Color){ .r = 255, .g = 255, .b = 180, .a = 255 });
  }
  if (g->state == GameState_GameOver) {
  rae_ext_drawText("GAME OVER", 100.0, 200.0, 40.0, (Color){ .r = 255, .g = 150, .b = 150, .a = 255 });
  rae_ext_drawText("Press R to Restart", 120.0, 250.0, 20.0, (Color){ .r = 220, .g = 220, .b = 220, .a = 255 });
  }
  rae_ext_endDrawing();
}

int main(void) {
  rae_ext_setConfigFlags(4);
  rae_ext_initWindow(400, 500, "Rae Tetris 2D");
  rae_ext_setTargetFPS(60);
  Game g = (Game){ .state = GameState_Menu, .grid = rae_createList_Int_(200), .width = 0, .height = 0, .currentPiece = { .kind = TetrominoKind_I, .pos = { .x = 0, .y = 0 }, .rotation = 0 }, .score = 0, .lines = 0, .level = 1, .moveTimer = 0, .moveDelay = 0 };
  rae_initGame_Game_(&(g));
  {
  while (rae_ext_windowShouldClose() == 0) {
  if (g.state == GameState_GameOver) {
  if (rae_ext_isKeyPressed(82) == 1) {
  rae_initGame_Game_(&(g));
  }
  }
  if (rae_ext_isKeyPressed(80) == 1) {
  if (g.state == GameState_Playing) {
  g.state = GameState_Paused;
  } else {
  if (g.state == GameState_Paused) {
  g.state = GameState_Playing;
  }
  }
  }
  if (g.state == GameState_Playing) {
  Piece* cp = &(g.currentPiece);
  Pos* pos = &(cp->pos);
  if (rae_ext_isKeyPressed(263) == 1) {
  if (rae_canMove_Game_Int_Int_Int_(&(g), (-1), 0, 0) == 1) {
  pos->x = pos->x - 1;
  }
  }
  if (rae_ext_isKeyPressed(262) == 1) {
  if (rae_canMove_Game_Int_Int_Int_(&(g), 1, 0, 0) == 1) {
  pos->x = pos->x + 1;
  }
  }
  if (rae_ext_isKeyPressed(32) == 1 || rae_ext_isKeyPressed(265) == 1) {
  if (rae_canMove_Game_Int_Int_Int_(&(g), 0, 0, 1) == 1) {
  cp->rotation = (cp->rotation + 1) % 4;
  }
  }
  int64_t effectiveDelay = g.moveDelay;
  if (rae_ext_isKeyDown(264) == 1) {
  effectiveDelay = 2;
  }
  g.moveTimer = g.moveTimer + 1;
  if (g.moveTimer >= effectiveDelay) {
  if (rae_canMove_Game_Int_Int_Int_(&(g), 0, 1, 0) == 1) {
  pos->y = pos->y + 1;
  } else {
  rae_lockPiece_Game_(&(g));
  rae_checkLines_Game_(&(g));
  rae_spawnPiece_Game_(&(g));
  }
  g.moveTimer = 0;
  }
  }
  rae_draw_Game_(&(g));
  }
  }
  rae_ext_closeWindow();
  return 0;
}

