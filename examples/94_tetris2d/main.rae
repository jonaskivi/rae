import raylib
import math
enum GameState { Menu, Playing, Paused, GameOver }

enum TetrominoKind {
  I
  J
  L
  O
  S
  T
  Z
}

type Pos {
  x: Int
  y: Int
}

type Piece {
  kind: TetrominoKind
  pos: Pos
  rotation: Int
}

# 0-3
type Game {
  state: GameState
  grid: List(Int)
  width: Int
  height: Int
  currentPiece: Piece
  score: Int
  lines: Int
  level: Int
  moveTimer: Int
  moveDelay: Int
  hMoveTimer: Int
  hMoveDelay: Int
}

func getModernColor(index: Int) ret Color {
  # I - Cyan
  if index is 1 {
    ret {
      r: 100
      g: 230
      b: 255
      a: 255
        }
  }
  # J - Blue
  if index is 2 {
    ret {
      r: 120
      g: 160
      b: 255
      a: 255
        }
  }
  # L - Orange
  if index is 3 {
    ret {
      r: 255
      g: 180
      b: 120
      a: 255
        }
  }
  # O - Yellow
  if index is 4 {
    ret {
      r: 255
      g: 230
      b: 120
      a: 255
        }
  }
  # S - Green
  if index is 5 {
    ret {
      r: 120
      g: 255
      b: 160
      a: 255
        }
  }
  # T - Purple
  if index is 6 {
    ret {
      r: 200
      g: 160
      b: 255
      a: 255
        }
  }
  # Z - Red
  if index is 7 {
    ret {
      r: 255
      g: 120
      b: 140
      a: 255
        }
  }
  # Empty
  ret {
    r: 40
    g: 40
    b: 50
    a: 255
    }
}

func getKindId(kind: TetrominoKind) ret Int {
  if kind is TetrominoKind.I {
    ret 1
  }
  if kind is TetrominoKind.J {
    ret 2
  }
  if kind is TetrominoKind.L {
    ret 3
  }
  if kind is TetrominoKind.O {
    ret 4
  }
  if kind is TetrominoKind.S {
    ret 5
  }
  if kind is TetrominoKind.T {
    ret 6
  }
  # Z
  ret 7
}

# Returns 1 if cell at (x, y) is occupied or out of bounds
func isOccupied(g: view Game, x: Int, y: Int) ret Int {
  if x < 0 or x >= g.width or y >= g.height {
    ret 1
  }
  if y < 0 {
    # Allow pieces above the board
    ret 0
  }
  if g.grid.get(index: y * g.width + x) > 0 {
    ret 1
  }
  ret 0
}

# Simple shape definitions (4x4 max)
func getShapeCell(kind: TetrominoKind, rot: Int, px: Int, py: Int) ret Int {
  if kind is TetrominoKind.I {
    if rot is 0 or rot is 2 {
      if px is 1 {
        ret 1
      }
    } else {
      if py is 1 {
        ret 1
      }
    }
  } else {
    if kind is TetrominoKind.J {
      if rot is 0 {
        if px is 1 and py >= 0 and py <= 2 or px is 0 and py is 2 {
          ret 1
        }
      } else {
        if rot is 1 {
          if py is 1 and px >= 0 and px <= 2 or px is 0 and py is 0 {
            ret 1
          }
        } else {
          if rot is 2 {
            if px is 1 and py >= 0 and py <= 2 or px is 2 and py is 0 {
              ret 1
            }
          } else {
            if rot is 3 {
              if py is 1 and px >= 0 and px <= 2 or px is 2 and py is 2 {
                ret 1
              }
            }
          }
        }
      }
    } else {
      if kind is TetrominoKind.L {
        if rot is 0 {
          if px is 1 and py >= 0 and py <= 2 or px is 2 and py is 2 {
            ret 1
          }
        } else {
          if rot is 1 {
            if py is 1 and px >= 0 and px <= 2 or px is 0 and py is 2 {
              ret 1
            }
          } else {
            if rot is 2 {
              if px is 1 and py >= 0 and py <= 2 or px is 0 and py is 0 {
                ret 1
              }
            } else {
              if rot is 3 {
                if py is 1 and px >= 0 and px <= 2 or px is 2 and py is 0 {
                  ret 1
                }
              }
            }
          }
        }
      } else {
        if kind is TetrominoKind.O {
          if px >= 1 and px <= 2 and py >= 1 and py <= 2 {
            ret 1
          }
        } else {
          if kind is TetrominoKind.S {
            if rot is 0 or rot is 2 {
              if py is 1 and px >= 1 and px <= 2 or py is 2 and px >= 0 and px <= 1 {
                ret 1
              }
            } else {
              if px is 1 and py >= 0 and py <= 1 or px is 2 and py >= 1 and py <= 2 {
                ret 1
              }
            }
          } else {
            if kind is TetrominoKind.T {
              if rot is 0 {
                if py is 1 and px >= 0 and px <= 2 or px is 1 and py is 0 {
                  ret 1
                }
              } else {
                if rot is 1 {
                  if px is 1 and py >= 0 and py <= 2 or px is 2 and py is 1 {
                    ret 1
                  }
                } else {
                  if rot is 2 {
                    if py is 1 and px >= 0 and px <= 2 or px is 1 and py is 2 {
                      ret 1
                    }
                  } else {
                    if rot is 3 {
                      if px is 1 and py >= 0 and py <= 2 or px is 0 and py is 1 {
                        ret 1
                      }
                    }
                  }
                }
              }
            } else {
              if kind is TetrominoKind.Z {
                if rot is 0 or rot is 2 {
                  if py is 1 and px >= 0 and px <= 1 or py is 2 and px >= 1 and px <= 2 {
                    ret 1
                  }
                } else {
                  if px is 1 and py >= 1 and py <= 2 or px is 2 and py >= 0 and py <= 1 {
                    ret 1
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  ret 0
}

func canMove(g: view Game, dx: Int, dy: Int, dr: Int) ret Int {
  let cp: view Piece => g.currentPiece
  let pos: view Pos => cp.pos
  let newX: Int = pos.x + dx
  let newY: Int = pos.y + dy
  let newRot: Int = (cp.rotation + dr) % 4
  if newRot < 0 {
    newRot = newRot + 4
  }
  let py: Int = 0
  loop py < 4 {
    let px: Int = 0
    loop px < 4 {
      if getShapeCell(
        kind: cp.kind
        rot: newRot
        px: px
        py: py
      ) is 1 {
        if isOccupied(g: g, x: newX + px, y: newY + py) is 1 {
          ret 0
        }
      }
      px = px + 1
    }
    py = py + 1
  }
  ret 1
}

func lockPiece(g: mod Game) {
  let cp: mod Piece => g.currentPiece
  let pos: view Pos => cp.pos
  let grid: mod List(Int) => g.grid
  let kindId: Int = getKindId(kind: cp.kind)
  let py: Int = 0
  loop py < 4 {
    let px: Int = 0
    loop px < 4 {
      if getShapeCell(
        kind: cp.kind
        rot: cp.rotation
        px: px
        py: py
      ) is 1 {
        let gx: Int = pos.x + px
        let gy: Int = pos.y + py
        if gy >= 0 and gy < g.height {
          grid.set(index: gy * g.width + gx, value: kindId)
        }
      }
      px = px + 1
    }
    py = py + 1
  }
}

func checkLines(g: mod Game) {
  let grid: mod List(Int) => g.grid
  let linesCleared: Int = 0
  let y: Int = g.height - 1
  loop y >= 0 {
    let full: Int = 1
    let x: Int = 0
    loop x < g.width {
      if grid.get(index: y * g.width + x) is 0 {
        full = 0
      }
      x = x + 1
    }
    if full is 1 {
      linesCleared = linesCleared + 1
      # Shift lines down
      let ty: Int = y
      loop ty > 0 {
        let tx: Int = 0
        loop tx < g.width {
          grid.set(index: ty * g.width + tx, value: grid.get(index: (ty - 1) * g.width + tx))
          tx = tx + 1
        }
        ty = ty - 1
      }
      # Top line is 0
      let tx: Int = 0
      loop tx < g.width {
        grid.set(index: tx, value: 0)
        tx = tx + 1
      }
      # Re-check same line
      y = y + 1
    }
    y = y - 1
  }
  if linesCleared > 0 {
    g.lines = g.lines + linesCleared
    g.score = g.score + linesCleared * 100 * g.level
    # Level progression: every 10 lines
    let newLevel: Int = g.lines / 10 + 1
    if newLevel > 10 {
      newLevel = 10
    }
    if newLevel > g.level {
      g.level = newLevel
      # Decrease delay (increase speed)
      g.moveDelay = 32 - g.level * 3
      if g.moveDelay < 2 {
        g.moveDelay = 2
      }
    }
  }
}

func spawnPiece(g: mod Game) {
  let cp: mod Piece => g.currentPiece
  let k: Int = random(min: 0, max: 6)
  if k is 0 {
    cp.kind = TetrominoKind.I
  } else {
    if k is 1 {
      cp.kind = TetrominoKind.J
    } else {
      if k is 2 {
        cp.kind = TetrominoKind.L
      } else {
        if k is 3 {
          cp.kind = TetrominoKind.O
        } else {
          if k is 4 {
            cp.kind = TetrominoKind.S
          } else {
            if k is 5 {
              cp.kind = TetrominoKind.T
            } else {
              cp.kind = TetrominoKind.Z
            }
          }
        }
      }
    }
  }
  let pos: mod Pos => cp.pos
  pos.x = g.width / 2 - 2
  pos.y = -1
  cp.rotation = 0
  if canMove(
    g: g
    dx: 0
    dy: 0
    dr: 0
  ) is 0 {
    g.state = GameState.GameOver
  }
}

func initGame(g: mod Game) {
  g.state = GameState.Playing
  g.width = 10
  g.height = 20
  g.score = 0
  g.lines = 0
  g.level = 1
  g.moveTimer = 0
  g.moveDelay = 30
  g.hMoveTimer = 0
  # tweak: 3â€“6 feels reasonable at 60fps
  g.hMoveDelay = 6
  # Initialize grid with 0s
  let i: Int = 0
  let grid: mod List(Int) => g.grid
  grid.clear()
  loop i < g.width * g.height {
    grid.add(value: 0)
    i = i + 1
  }
  spawnPiece(g)
}

func draw(g: view Game) {
  beginDrawing()
  clearBackground(color: {
    r: 30
    g: 30
    b: 40
    a: 255
    })
  let sw: Float = getScreenWidth().toFloat()
  let sh: Float = getScreenHeight().toFloat()
  # Calculate scaling: target height is 20 rows, let's leave 10% margin top/bottom
  let cellSize: Float = sh * 0.8 / 20.0
  let offsetX: Float = (sw - g.width.toFloat() * cellSize) / 2.0
  let offsetY: Float = (sh - g.height.toFloat() * cellSize) / 2.0
  # Draw Grid Area Outline (Modern Pastel Lavender)
  # Draw Grid
  drawRectangleLines(
    x: offsetX - 2.0
    y: offsetY - 2.0
    width: g.width.toFloat() * cellSize + 4.0
    height: g.height.toFloat() * cellSize + 4.0
    color: {
      r: 180
      g: 180
      b: 255
      a: 255
        }
  )
  let y: Int = 0
  loop y < g.height {
    let x: Int = 0
    loop x < g.width {
      let val: Int = g.grid.get(index: y * g.width + x)
      if val > 0 {
        drawRectangle(
          x: x.toFloat() * cellSize + offsetX
          y: y.toFloat() * cellSize + offsetY
          width: cellSize - 1.0
          height: cellSize - 1.0
          color: getModernColor(id: val)
        )
      }
      x = x + 1
    }
    y = y + 1
  }
  # Draw current piece
  let cp: view Piece => g.currentPiece
  let pos: view Pos => cp.pos
  let kindId: Int = getKindId(kind: cp.kind)
  let py: Int = 0
  loop py < 4 {
    let px: Int = 0
    loop px < 4 {
      if getShapeCell(
        kind: cp.kind
        rot: cp.rotation
        px: px
        py: py
      ) is 1 {
        drawRectangle(
          x: (pos.x + px).toFloat() * cellSize + offsetX
          y: (pos.y + py).toFloat() * cellSize + offsetY
          width: cellSize - 1.0
          height: cellSize - 1.0
          color: getModernColor(id: kindId)
        )
      }
      px = px + 1
    }
    py = py + 1
  }
  # UI Text (Modern Pastel Rainbow Palette)
  # Scale font size based on screen height
  let fontSize: Float = sh / 25.0
  if fontSize < 10.0 {
    fontSize = 10.0
  }
  # Soft Pink
  # Soft Green
  drawText(
    text: "SCORE: {g.score}"
    x: 10.0
    y: 10.0
    fontSize: fontSize
    color: {
      r: 255
      g: 200
      b: 200
      a: 255
        }
  )
  # Soft Blue
  drawText(
    text: "LEVEL: {g.level}"
    x: 10.0
    y: 10.0 + fontSize * 1.2
    fontSize: fontSize
    color: {
      r: 200
      g: 255
      b: 200
      a: 255
        }
  )
  drawText(
    text: "LINES: {g.lines}"
    x: 10.0
    y: 10.0 + fontSize * 2.4
    fontSize: fontSize
    color: {
      r: 200
      g: 200
      b: 255
      a: 255
        }
  )
  if g.state is GameState.Paused {
    # Soft Yellow
    drawText(
      text: "PAUSED"
      x: sw / 2.0 - fontSize * 3.0
      y: sh / 2.0
      fontSize: fontSize * 2.0
      color: {
        r: 255
        g: 255
        b: 180
        a: 255
            }
    )
  }
  if g.state is GameState.GameOver {
    # Soft Red
    # Light Gray
    drawText(
      text: "GAME OVER"
      x: sw / 2.0 - fontSize * 4.0
      y: sh / 2.0
      fontSize: fontSize * 2.0
      color: {
        r: 255
        g: 150
        b: 150
        a: 255
            }
    )
    drawText(
      text: "Press R to Restart"
      x: sw / 2.0 - fontSize * 4.0
      y: sh / 2.0 + fontSize * 2.2
      fontSize: fontSize
      color: {
        r: 220
        g: 220
        b: 220
        a: 255
            }
    )
  }
  endDrawing()
}

func handleInput(g: mod Game) {
  if g.state is not GameState.Playing {
    ret
  }
  let cp: mod Piece => g.currentPiece
  let pos: mod Pos => cp.pos
  # Horizontal repeat timer
  g.hMoveTimer = g.hMoveTimer + 1
  let moveLeft: Int = isKeyDown(key: 263) or isKeyDown(key: 65)
  let moveRight: Int = isKeyDown(key: 262) or isKeyDown(key: 68)
  if g.hMoveTimer >= g.hMoveDelay {
    if moveLeft is 1 and moveRight is 0 {
      if canMove(
        g: g
        dx: -1
        dy: 0
        dr: 0
      ) is 1 {
        pos.x = pos.x - 1
        g.hMoveTimer = 0
      }
    }
    if moveRight is 1 and moveLeft is 0 {
      if canMove(
        g: g
        dx: 1
        dy: 0
        dr: 0
      ) is 1 {
        pos.x = pos.x + 1
        g.hMoveTimer = 0
      }
    }
  }
  # Reset when no horizontal key held
  if moveLeft is 0 and moveRight is 0 {
    g.hMoveTimer = g.hMoveTimer
  }
  # Rotate (still single-press)
  if isKeyPressed(key: 32) is 1 or isKeyPressed(key: 265) is 1 or isKeyPressed(key: 87) is 1 {
    if canMove(
      g: g
      dx: 0
      dy: 0
      dr: 1
    ) is 1 {
      cp.rotation = (cp.rotation + 1) % 4
    }
  }
  # Soft Drop
  let effectiveDelay: Int = g.moveDelay
  if isKeyDown(key: 264) is 1 or isKeyDown(key: 83) is 1 {
    effectiveDelay = 2
  }
  # Gravity
  g.moveTimer = g.moveTimer + 1
  if g.moveTimer >= effectiveDelay {
    if canMove(
      g: g
      dx: 0
      dy: 1
      dr: 0
    ) is 1 {
      pos.y = pos.y + 1
    } else {
      lockPiece(g)
      checkLines(g)
      spawnPiece(g)
    }
    g.moveTimer = 0
  }
}

func main() {
  # FLAG_WINDOW_RESIZABLE = 4
  # We can't easily use Bitwise OR yet, so just 4
  setConfigFlags(flags: 4)
  initWindow(width: 400, height: 500, title: "Rae Tetris 2D")
  setTargetFPS(fps: 60)
  let g: Game = {
    state: GameState.Menu
    grid: createList(initialCap: 200)
    width: 0
    height: 0
    currentPiece: { kind: TetrominoKind.I, pos: { x: 0, y: 0 }, rotation: 0 }
    score: 0
    lines: 0
    level: 1
    moveTimer: 0
    moveDelay: 0
    hMoveTimer: 0
    hMoveDelay: 0
    }
  initGame(g)
  loop windowShouldClose() is 0 {
    # Input: Global (Menu/GameOver)
    if g.state is GameState.GameOver {
      # R key
      if isKeyPressed(key: 82) is 1 {
        initGame(g)
      }
    }
    # Input: Pause
    # P key
    if isKeyPressed(key: 80) is 1 {
      if g.state is GameState.Playing {
        g.state = GameState.Paused
      } else {
        if g.state is GameState.Paused {
          g.state = GameState.Playing
        }
      }
    }
    # early returns don't work yet, so gate it here.
    if g.state is GameState.Playing {
      handleInput(g)
    }
    draw(g)
  }
  closeWindow()
}
