import raylib
import math
enum GameState {
  Menu,
  Playing,
  Paused,
  GameOver
}

enum TetrominoKind {
  I,
  J,
  L,
  O,
  S,
  T,
  Z
}

type Pos {
  x: Int
  y: Int
}

type Piece {
  kind: TetrominoKind
  pos: Pos
  rotation: Int
}

# 0-3
type Game {
  state: GameState
  grid: List(Int)
  width: Int
  height: Int
  currentPiece: Piece
  score: Int
  moveTimer: Int
  moveDelay: Int
}

# Returns 1 if cell at (x, y) is occupied or out of bounds
func isOccupied(g: view Game, x: Int, y: Int): ret Int {
  if x < 0 or x >= g.width or y >= g.height {
    ret 1
  }
  if y < 0 {
    # Allow pieces above the board
    ret 0
  }
  ret g.grid.get(index: y * g.width + x)
}

# Simple shape definitions (4x4 max)
func getShapeCell(kind: TetrominoKind, rot: Int, px: Int, py: Int): ret Int {
  # Shapes defined as 16-bit integers (4x4 grids)
  # This is a bit tedious to do manually without arrays, 
  # but we can use if/match for now.
  # For brevity in this example, we'll use a few simple cases
  if kind is TetrominoKind.I {
    if rot is 0 or rot is 2 {
      if px is 1 {
        ret 1
      }
    } else {
      if py is 1 {
        ret 1
      }
    }
  }
  if kind is TetrominoKind.O {
    if px >= 1 and px <= 2 and py >= 1 and py <= 2 {
      ret 1
    }
  }
  if kind is TetrominoKind.T {
    if rot is 0 {
      if px is 1 and py is 0 or px >= 0 and px <= 2 and py is 1 {
        ret 1
      }
    }
    if rot is 1 {
      if px is 1 and py >= 0 and px <= 2 or px is 2 and py is 1 {
        ret 1
      }
    }
    # ... Simplified for first version ...
    # Dummy placeholder for T
    if px is 1 or py is 1 {
      ret 1
    }
  }
  ret 0
}

func spawnPiece(g: mod Game) {
  # Randomize later
  def cp: mod Piece => g.currentPiece
  cp.kind = TetrominoKind.I
  def pos: mod Pos => cp.pos
  pos.x = g.width / 2 - 2
  pos.y = -1
  cp.rotation = 0
}

func initGame(g: mod Game) {
  g.state = GameState.Playing
  g.width = 10
  g.height = 20
  g.score = 0
  g.moveTimer = 0
  # frames
  g.moveDelay = 30
  # Initialize grid with 0s
  def i: Int = 0
  log("Initializing grid of size {g.width * g.height}")
  loop i < g.width * g.height {
    g.grid.add(value: 0)
    i = i + 1
  }
  log("Grid initialized")
  spawnPiece(g)
  log("First piece spawned")
}

func draw(g: view Game) {
  beginDrawing()
  # Draw Grid
  clearBackground(color: {
    r: 20,
    g: 20,
    b: 25,
    a: 255,
  })
  def y: Int = 0
  def grid: view List(Int) => g.grid
  log("Drawing grid {g.width}x{g.height}, list length {grid.length}")
  loop y < g.height {
    def x: Int = 0
    loop x < g.width {
      def idx: Int = y * g.width + x
      def val: Int = g.grid.get(index: idx)
      if val > 0 {
        drawRectangle(
          x: (x * 20 + 100).toFloat(),
          y: (y * 20 + 50).toFloat(),
          width: 18.0,
          height: 18.0,
          color: {
            r: 100,
            g: 100,
            b: 255,
            a: 255,
          },
        )
      }
      x = x + 1
    }
    y = y + 1
  }
  # Draw current piece
  def cp: view Piece => g.currentPiece
  def pos: view Pos => cp.pos
  def py: Int = 0
  loop py < 4 {
    def px: Int = 0
    loop px < 4 {
      if getShapeCell(
        kind: cp.kind,
        rot: cp.rotation,
        px: px,
        py: py,
      ) is 1 {
        drawRectangle(
          x: ((pos.x + px) * 20 + 100).toFloat(),
          y: ((pos.y + py) * 20 + 50).toFloat(),
          width: 18.0,
          height: 18.0,
          color: {
            r: 255,
            g: 100,
            b: 100,
            a: 255,
          },
        )
      }
      px = px + 1
    }
    py = py + 1
  }
  drawText(
    text: "Score: {g.score}",
    x: 10.0,
    y: 10.0,
    fontSize: 20.0,
    color: {
      r: 255,
      g: 255,
      b: 255,
      a: 255,
    },
  )
  if g.state is GameState.Paused {
    drawText(
      text: "PAUSED",
      x: 300.0,
      y: 200.0,
      fontSize: 40.0,
      color: {
        r: 255,
        g: 255,
        b: 0,
        a: 255,
      },
    )
  }
  endDrawing()
}

func main() {
  initWindow(width: 400, height: 500, title: "Rae Tetris 2D")
  setTargetFPS(fps: 60)
  def g: Game = {
    state: GameState.Menu,
    grid: createList(initialCap: 200),
    width: 0,
    height: 0,
    currentPiece: {kind: TetrominoKind.I, pos: {x: 0, y: 0}, rotation: 0},
    score: 0,
    moveTimer: 0,
    moveDelay: 0,
  }
  initGame(g)
  log("Entering main loop")
  loop windowShouldClose() is 0 {
    # Input
    # P key
    if isKeyDown(key: 80) is 1 {
      log("P pressed")
      if g.state is GameState.Playing {
        g.state = GameState.Paused
      } else {
        if g.state is GameState.Paused {
          g.state = GameState.Playing
        }
      }
    }
    if g.state is GameState.Playing {
      # Left/Right
      # Very basic, no collision check yet
      def cp: mod Piece => g.currentPiece
      def pos: mod Pos => cp.pos
      if isKeyDown(key: 263) is 1 {
        pos.x = pos.x - 1
      }
      if isKeyDown(key: 262) is 1 {
        pos.x = pos.x + 1
      }
      # Gravity
      g.moveTimer = g.moveTimer + 1
      if g.moveTimer >= g.moveDelay {
        pos.y = pos.y + 1
        g.moveTimer = 0
        # Lock piece if it hits bottom
        if pos.y > 15 {
          pos.y = 0
          g.score = g.score + 10
        }
      }
    }
    draw(g)
  }
  closeWindow()
}
