import raylib
import math

enum GameState {
  Menu
  Playing
  Paused
  GameOver
}

enum TetrominoKind {
  I
  J
  L
  O
  S
  T
  Z
}

type Pos {
  x: Int
  y: Int
}

type Piece {
  kind: TetrominoKind
  pos: Pos
  rotation: Int # 0-3
}

type Game {
  state: GameState
  grid: List(Int)
  width: Int
  height: Int
  currentPiece: Piece
  score: Int
  moveTimer: Int
  moveDelay: Int
}

# Returns 1 if cell at (x, y) is occupied or out of bounds
func isOccupied(g: view Game, x: Int, y: Int) ret Int {
  if x < 0 or x >= g.width or y >= g.height {
    ret 1
  }
  if y < 0 {
    ret 0 # Allow pieces above the board
  }
  ret g.grid.get(index: y * g.width + x)
}

# Simple shape definitions (4x4 max)
func getShapeCell(kind: TetrominoKind, rot: Int, px: Int, py: Int) ret Int {
  if kind is TetrominoKind.I {
    if rot is 0 or rot is 2 {
      if px is 1 {
        ret 1
      }
    } else {
      if py is 1 {
        ret 1
      }
    }
  } else if kind is TetrominoKind.J {
    if rot is 0 {
      if (px is 1 and py >= 0 and py <= 2) or (px is 0 and py is 2) {
        ret 1
      }
    } else if rot is 1 {
      if (py is 1 and px >= 0 and px <= 2) or (px is 0 and py is 0) {
        ret 1
      }
    } else if rot is 2 {
      if (px is 1 and py >= 0 and py <= 2) or (px is 2 and py is 0) {
        ret 1
      }
    } else if rot is 3 {
      if (py is 1 and px >= 0 and px <= 2) or (px is 2 and py is 2) {
        ret 1
      }
    }
  } else if kind is TetrominoKind.L {
    if rot is 0 {
      if (px is 1 and py >= 0 and py <= 2) or (px is 2 and py is 2) {
        ret 1
      }
    } else if rot is 1 {
      if (py is 1 and px >= 0 and px <= 2) or (px is 0 and py is 2) {
        ret 1
      }
    } else if rot is 2 {
      if (px is 1 and py >= 0 and py <= 2) or (px is 0 and py is 0) {
        ret 1
      }
    } else if rot is 3 {
      if (py is 1 and px >= 0 and px <= 2) or (px is 2 and py is 0) {
        ret 1
      }
    }
  } else if kind is TetrominoKind.O {
    if px >= 1 and px <= 2 and py >= 1 and py <= 2 {
      ret 1
    }
  } else if kind is TetrominoKind.S {
    if rot is 0 or rot is 2 {
      if (py is 1 and px >= 1 and px <= 2) or (py is 2 and px >= 0 and px <= 1) {
        ret 1
      }
    } else {
      if (px is 1 and py >= 0 and py <= 1) or (px is 2 and py >= 1 and py <= 2) {
        ret 1
      }
    }
  } else if kind is TetrominoKind.T {
    if rot is 0 {
      if (py is 1 and px >= 0 and px <= 2) or (px is 1 and py is 0) {
        ret 1
      }
    } else if rot is 1 {
      if (px is 1 and py >= 0 and py <= 2) or (px is 2 and py is 1) {
        ret 1
      }
    } else if rot is 2 {
      if (py is 1 and px >= 0 and px <= 2) or (px is 1 and py is 2) {
        ret 1
      }
    } else if rot is 3 {
      if (px is 1 and py >= 0 and py <= 2) or (px is 0 and py is 1) {
        ret 1
      }
    }
  } else if kind is TetrominoKind.Z {
    if rot is 0 or rot is 2 {
      if (py is 1 and px >= 0 and px <= 1) or (py is 2 and px >= 1 and px <= 2) {
        ret 1
      }
    } else {
      if (px is 1 and py >= 1 and py <= 2) or (px is 2 and py >= 0 and py <= 1) {
        ret 1
      }
    }
  }
  ret 0
}

func canMove(g: view Game, dx: Int, dy: Int, dr: Int) ret Int {
  def cp: view Piece => g.currentPiece
  def pos: view Pos => cp.pos
  def newX: Int = pos.x + dx
  def newY: Int = pos.y + dy
  def newRot: Int = (cp.rotation + dr) % 4
  if newRot < 0 {
    newRot = newRot + 4
  }
  
  def py: Int = 0
  loop py < 4 {
    def px: Int = 0
    loop px < 4 {
      if getShapeCell(kind: cp.kind, rot: newRot, px: px, py: py) is 1 {
        if isOccupied(g: g, x: newX + px, y: newY + py) is 1 {
          ret 0
        }
      }
      px = px + 1
    }
    py = py + 1
  }
  ret 1
}

func lockPiece(g: mod Game) {
  def cp: mod Piece => g.currentPiece
  def pos: view Pos => cp.pos
  def grid: mod List(Int) => g.grid
  def py: Int = 0
  loop py < 4 {
    def px: Int = 0
    loop px < 4 {
      if getShapeCell(
        kind: cp.kind
        rot: cp.rotation
        px: px
        py: py
      ) is 1 {
        def gx: Int = pos.x + px
        def gy: Int = pos.y + py
        if gy >= 0 and gy < g.height {
          grid.set(index: gy * g.width + gx, value: 1)
        }
      }
      px = px + 1
    }
    py = py + 1
  }
}

func checkLines(g: mod Game) {
  def grid: mod List(Int) => g.grid
  def y: Int = g.height - 1
  loop y >= 0 {
    def full: Int = 1
    def x: Int = 0
    loop x < g.width {
      if grid.get(index: y * g.width + x) is 0 {
        full = 0
      }
      x = x + 1
    }
    
    if full is 1 {
      g.score = g.score + 100
      # Shift lines down
      def ty: Int = y
      loop ty > 0 {
        def tx: Int = 0
        loop tx < g.width {
          grid.set(index: ty * g.width + tx, value: grid.get(index: (ty - 1) * g.width + tx))
          tx = tx + 1
        }
        ty = ty - 1
      }
      # Top line is 0
      def tx: Int = 0
      loop tx < g.width {
        grid.set(index: tx, value: 0)
        tx = tx + 1
      }
      # Re-check same line
      y = y + 1
    }
    y = y - 1
  }
}

func spawnPiece(g: mod Game) {
  def cp: mod Piece => g.currentPiece
  def k: Int = random(min: 0, max: 6)
  if k is 0 {
    cp.kind = TetrominoKind.I
  } else if k is 1 {
    cp.kind = TetrominoKind.J
  } else if k is 2 {
    cp.kind = TetrominoKind.L
  } else if k is 3 {
    cp.kind = TetrominoKind.O
  } else if k is 4 {
    cp.kind = TetrominoKind.S
  } else if k is 5 {
    cp.kind = TetrominoKind.T
  } else {
    cp.kind = TetrominoKind.Z
  }
  
  def pos: mod Pos => cp.pos
  pos.x = g.width / 2 - 2
  pos.y = -1
  cp.rotation = 0
  
  if canMove(g: g, dx: 0, dy: 0, dr: 0) is 0 {
    g.state = GameState.GameOver
  }
}

func initGame(g: mod Game) {
  g.state = GameState.Playing
  g.width = 10
  g.height = 20
  g.score = 0
  g.moveTimer = 0
  # frames
  g.moveDelay = 30
  # Initialize grid with 0s
  def i: Int = 0
  def grid: mod List(Int) => g.grid
  loop i < g.width * g.height {
    grid.add(value: 0)
    i = i + 1
  }
  spawnPiece(g)
}

func draw(g: view Game) {
  beginDrawing()
  clearBackground(color: {
    r: 20
    g: 20
    b: 25
    a: 255
  })
  
  # Draw Grid
  def y: Int = 0
  loop y < g.height {
    def x: Int = 0
    loop x < g.width {
      def val: Int = g.grid.get(index: y * g.width + x)
      if val > 0 {
        drawRectangle(
          x: (x * 20 + 100).toFloat()
          y: (y * 20 + 50).toFloat()
          width: 18.0
          height: 18.0
          color: {
            r: 100
            g: 100
            b: 255
            a: 255
          }
        )
      }
      x = x + 1
    }
    y = y + 1
  }
  
  # Draw current piece
  def cp: view Piece => g.currentPiece
  def pos: view Pos => cp.pos
  def py: Int = 0
  loop py < 4 {
    def px: Int = 0
    loop px < 4 {
      if getShapeCell(
        kind: cp.kind
        rot: cp.rotation
        px: px
        py: py
      ) is 1 {
        drawRectangle(
          x: ((pos.x + px) * 20 + 100).toFloat()
          y: ((pos.y + py) * 20 + 50).toFloat()
          width: 18.0
          height: 18.0
          color: {
            r: 255
            g: 100
            b: 100
            a: 255
          }
        )
      }
      px = px + 1
    }
    py = py + 1
  }
  
  drawText(
    text: "Score: {g.score}"
    x: 10.0
    y: 10.0
    fontSize: 20.0
    color: {
      r: 255
      g: 255
      b: 255
      a: 255
    }
  )
  
  if g.state is GameState.Paused {
    drawText(
      text: "PAUSED"
      x: 150.0
      y: 200.0
      fontSize: 40.0
      color: {
        r: 255
        g: 255
        b: 0
        a: 255
      }
    )
  }
  if g.state is GameState.GameOver {
    drawText(
      text: "GAME OVER"
      x: 100.0
      y: 200.0
      fontSize: 40.0
      color: {
        r: 255
        g: 0
        b: 0
        a: 255
      }
    )
    drawText(
      text: "Press R to Restart"
      x: 120.0
      y: 250.0
      fontSize: 20.0
      color: {
        r: 255
        g: 255
        b: 255
        a: 255
      }
    )
  }
  
  endDrawing()
}

func main() {
  initWindow(width: 400, height: 500, title: "Rae Tetris 2D")
  setTargetFPS(fps: 60)
  
  def g: Game = {
    state: GameState.Menu
    grid: createList(initialCap: 200)
    width: 0
    height: 0
    currentPiece: {
      kind: TetrominoKind.I
      pos: {
        x: 0
        y: 0
      }
      rotation: 0
    }
    score: 0
    moveTimer: 0
    moveDelay: 0
  }
  
  initGame(g)
  
  loop windowShouldClose() is 0 {
    # Input: Global (Menu/GameOver)
    if g.state is GameState.GameOver {
      if isKeyPressed(key: 82) is 1 { # R key
        g.grid.clear()
        initGame(g)
      }
    }
    
    # Input: Pause
    if isKeyPressed(key: 80) is 1 { # P key
      if g.state is GameState.Playing {
        g.state = GameState.Paused
      } else if g.state is GameState.Paused {
        g.state = GameState.Playing
      }
    }
    
    if g.state is GameState.Playing {
      def cp: mod Piece => g.currentPiece
      def pos: mod Pos => cp.pos
      
      # Left/Right
      if isKeyPressed(key: 263) is 1 {
        if canMove(g: g, dx: -1, dy: 0, dr: 0) is 1 {
          pos.x = pos.x - 1
        }
      }
      if isKeyPressed(key: 262) is 1 {
        if canMove(g: g, dx: 1, dy: 0, dr: 0) is 1 {
          pos.x = pos.x + 1
        }
      }
      
      # Rotate
      if isKeyPressed(key: 32) is 1 or isKeyPressed(key: 265) is 1 { # Space or Up
        if canMove(g: g, dx: 0, dy: 0, dr: 1) is 1 {
          cp.rotation = (cp.rotation + 1) % 4
        }
      }
      
      # Soft Drop
      def effectiveDelay: Int = g.moveDelay
      if isKeyDown(key: 264) is 1 { # Down arrow
        effectiveDelay = 2
      }
      
      # Gravity
      g.moveTimer = g.moveTimer + 1
      if g.moveTimer >= effectiveDelay {
        if canMove(g: g, dx: 0, dy: 1, dr: 0) is 1 {
          pos.y = pos.y + 1
        } else {
          lockPiece(g)
          checkLines(g)
          spawnPiece(g)
        }
        g.moveTimer = 0
      }
    }
    
    draw(g)
  }
  
  closeWindow()
}


