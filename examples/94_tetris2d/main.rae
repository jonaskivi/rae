import raylib
import math

enum GameState {
  Menu
  Playing
  Paused
  GameOver
}

enum TetrominoKind {
  I
  J
  L
  O
  S
  T
  Z
}

type Pos {
  x: Int
  y: Int
}

type Piece {
  kind: TetrominoKind
  pos: Pos
  rotation: Int # 0-3
}

type Game {
  state: GameState
  grid: List(Int)
  width: Int
  height: Int
  currentPiece: Piece
  score: Int
  lines: Int
  level: Int
  moveTimer: Int
  moveDelay: Int
}

func getModernColor(id: Int) ret Color {
  if id is 1 { # I - Cyan
    ret { r: 100, g: 230, b: 255, a: 255 }
  }
  if id is 2 { # J - Blue
    ret { r: 120, g: 160, b: 255, a: 255 }
  }
  if id is 3 { # L - Orange
    ret { r: 255, g: 180, b: 120, a: 255 }
  }
  if id is 4 { # O - Yellow
    ret { r: 255, g: 230, b: 120, a: 255 }
  }
  if id is 5 { # S - Green
    ret { r: 120, g: 255, b: 160, a: 255 }
  }
  if id is 6 { # T - Purple
    ret { r: 200, g: 160, b: 255, a: 255 }
  }
  if id is 7 { # Z - Red
    ret { r: 255, g: 120, b: 140, a: 255 }
  }
  # Empty
  ret { r: 40, g: 40, b: 50, a: 255 }
}

func getKindId(kind: TetrominoKind) ret Int {
  if kind is TetrominoKind.I { ret 1 }
  if kind is TetrominoKind.J { ret 2 }
  if kind is TetrominoKind.L { ret 3 }
  if kind is TetrominoKind.O { ret 4 }
  if kind is TetrominoKind.S { ret 5 }
  if kind is TetrominoKind.T { ret 6 }
  ret 7 # Z
}

# Returns 1 if cell at (x, y) is occupied or out of bounds
func isOccupied(g: view Game, x: Int, y: Int) ret Int {
  if x < 0 or x >= g.width or y >= g.height {
    ret 1
  }
  if y < 0 {
    ret 0 # Allow pieces above the board
  }
  if g.grid.get(index: y * g.width + x) > 0 {
    ret 1
  }
  ret 0
}

# Simple shape definitions (4x4 max)
func getShapeCell(kind: TetrominoKind, rot: Int, px: Int, py: Int) ret Int {
  if kind is TetrominoKind.I {
    if rot is 0 or rot is 2 {
      if px is 1 {
        ret 1
      }
    } else {
      if py is 1 {
        ret 1
      }
    }
  } else if kind is TetrominoKind.J {
    if rot is 0 {
      if (px is 1 and py >= 0 and py <= 2) or (px is 0 and py is 2) {
        ret 1
      }
    } else if rot is 1 {
      if (py is 1 and px >= 0 and px <= 2) or (px is 0 and py is 0) {
        ret 1
      }
    } else if rot is 2 {
      if (px is 1 and py >= 0 and py <= 2) or (px is 2 and py is 0) {
        ret 1
      }
    } else if rot is 3 {
      if (py is 1 and px >= 0 and px <= 2) or (px is 2 and py is 2) {
        ret 1
      }
    }
  } else if kind is TetrominoKind.L {
    if rot is 0 {
      if (px is 1 and py >= 0 and py <= 2) or (px is 2 and py is 2) {
        ret 1
      }
    } else if rot is 1 {
      if (py is 1 and px >= 0 and px <= 2) or (px is 0 and py is 2) {
        ret 1
      }
    } else if rot is 2 {
      if (px is 1 and py >= 0 and py <= 2) or (px is 0 and py is 0) {
        ret 1
      }
    } else if rot is 3 {
      if (py is 1 and px >= 0 and px <= 2) or (px is 2 and py is 0) {
        ret 1
      }
    }
  } else if kind is TetrominoKind.O {
    if px >= 1 and px <= 2 and py >= 1 and py <= 2 {
      ret 1
    }
  } else if kind is TetrominoKind.S {
    if rot is 0 or rot is 2 {
      if (py is 1 and px >= 1 and px <= 2) or (py is 2 and px >= 0 and px <= 1) {
        ret 1
      }
    } else {
      if (px is 1 and py >= 0 and py <= 1) or (px is 2 and py >= 1 and py <= 2) {
        ret 1
      }
    }
  } else if kind is TetrominoKind.T {
    if rot is 0 {
      if (py is 1 and px >= 0 and px <= 2) or (px is 1 and py is 0) {
        ret 1
      }
    } else if rot is 1 {
      if (px is 1 and py >= 0 and py <= 2) or (px is 2 and py is 1) {
        ret 1
      }
    } else if rot is 2 {
      if (py is 1 and px >= 0 and px <= 2) or (px is 1 and py is 2) {
        ret 1
      }
    } else if rot is 3 {
      if (px is 1 and py >= 0 and py <= 2) or (px is 0 and py is 1) {
        ret 1
      }
    }
  } else if kind is TetrominoKind.Z {
    if rot is 0 or rot is 2 {
      if (py is 1 and px >= 0 and px <= 1) or (py is 2 and px >= 1 and px <= 2) {
        ret 1
      }
    } else {
      if (px is 1 and py >= 1 and py <= 2) or (px is 2 and py >= 0 and py <= 1) {
        ret 1
      }
    }
  }
  ret 0
}

func canMove(g: view Game, dx: Int, dy: Int, dr: Int) ret Int {
  def cp: view Piece => g.currentPiece
  def pos: view Pos => cp.pos
  def newX: Int = pos.x + dx
  def newY: Int = pos.y + dy
  def newRot: Int = (cp.rotation + dr) % 4
  if newRot < 0 {
    newRot = newRot + 4
  }
  
  def py: Int = 0
  loop py < 4 {
    def px: Int = 0
    loop px < 4 {
      if getShapeCell(kind: cp.kind, rot: newRot, px: px, py: py) is 1 {
        if isOccupied(g: g, x: newX + px, y: newY + py) is 1 {
          ret 0
        }
      }
      px = px + 1
    }
    py = py + 1
  }
  ret 1
}

func lockPiece(g: mod Game) {
  def cp: mod Piece => g.currentPiece
  def pos: view Pos => cp.pos
  def grid: mod List(Int) => g.grid
  def kindId: Int = getKindId(kind: cp.kind)
  def py: Int = 0
  loop py < 4 {
    def px: Int = 0
    loop px < 4 {
      if getShapeCell(
        kind: cp.kind
        rot: cp.rotation
        px: px
        py: py
      ) is 1 {
        def gx: Int = pos.x + px
        def gy: Int = pos.y + py
        if gy >= 0 and gy < g.height {
          grid.set(index: gy * g.width + gx, value: kindId)
        }
      }
      px = px + 1
    }
    py = py + 1
  }
}

func checkLines(g: mod Game) {
  def grid: mod List(Int) => g.grid
  def linesCleared: Int = 0
  def y: Int = g.height - 1
  loop y >= 0 {
    def full: Int = 1
    def x: Int = 0
    loop x < g.width {
      if grid.get(index: y * g.width + x) is 0 {
        full = 0
      }
      x = x + 1
    }
    
    if full is 1 {
      linesCleared = linesCleared + 1
      # Shift lines down
      def ty: Int = y
      loop ty > 0 {
        def tx: Int = 0
        loop tx < g.width {
          grid.set(index: ty * g.width + tx, value: grid.get(index: (ty - 1) * g.width + tx))
          tx = tx + 1
        }
        ty = ty - 1
      }
      # Top line is 0
      def tx: Int = 0
      loop tx < g.width {
        grid.set(index: tx, value: 0)
        tx = tx + 1
      }
      # Re-check same line
      y = y + 1
    }
    y = y - 1
  }
  
  if linesCleared > 0 {
    g.lines = g.lines + linesCleared
    g.score = g.score + (linesCleared * 100 * g.level)
    
    # Level progression: every 10 lines
    def newLevel: Int = (g.lines / 10) + 1
    if newLevel > 10 {
      newLevel = 10
    }
    if newLevel > g.level {
      g.level = newLevel
      # Decrease delay (increase speed)
      g.moveDelay = 32 - (g.level * 3)
      if g.moveDelay < 2 {
        g.moveDelay = 2
      }
    }
  }
}

func spawnPiece(g: mod Game) {
  def cp: mod Piece => g.currentPiece
  def k: Int = random(min: 0, max: 6)
  if k is 0 {
    cp.kind = TetrominoKind.I
  } else if k is 1 {
    cp.kind = TetrominoKind.J
  } else if k is 2 {
    cp.kind = TetrominoKind.L
  } else if k is 3 {
    cp.kind = TetrominoKind.O
  } else if k is 4 {
    cp.kind = TetrominoKind.S
  } else if k is 5 {
    cp.kind = TetrominoKind.T
  } else {
    cp.kind = TetrominoKind.Z
  }
  
  def pos: mod Pos => cp.pos
  pos.x = g.width / 2 - 2
  pos.y = -1
  cp.rotation = 0
  
  if canMove(g: g, dx: 0, dy: 0, dr: 0) is 0 {
    g.state = GameState.GameOver
  }
}

func initGame(g: mod Game) {
  g.state = GameState.Playing
  g.width = 10
  g.height = 20
  g.score = 0
  g.lines = 0
  g.level = 1
  g.moveTimer = 0
  g.moveDelay = 30
  
  # Initialize grid with 0s
  def i: Int = 0
  def grid: mod List(Int) => g.grid
  grid.clear()
  loop i < g.width * g.height {
    grid.add(value: 0)
    i = i + 1
  }
  spawnPiece(g)
}

func draw(g: view Game) {
  beginDrawing()
  clearBackground(color: {
    r: 30
    g: 30
    b: 40
    a: 255
  })
  
  def offsetX: Float = 100.0
  def offsetY: Float = 50.0
  def cellSize: Float = 20.0
  
  # Draw Grid Area Outline (Modern Pastel Lavender)
  drawRectangleLines(
    x: offsetX - 2.0
    y: offsetY - 2.0
    width: (g.width.toFloat() * cellSize) + 4.0
    height: (g.height.toFloat() * cellSize) + 4.0
    color: { r: 180, g: 180, b: 255, a: 255 }
  )
  
  # Draw Grid
  def y: Int = 0
  loop y < g.height {
    def x: Int = 0
    loop x < g.width {
      def val: Int = g.grid.get(index: y * g.width + x)
      if val > 0 {
        drawRectangle(
          x: x.toFloat() * cellSize + offsetX
          y: y.toFloat() * cellSize + offsetY
          width: cellSize - 1.0
          height: cellSize - 1.0
          color: getModernColor(id: val)
        )
      }
      x = x + 1
    }
    y = y + 1
  }
  
  # Draw current piece
  def cp: view Piece => g.currentPiece
  def pos: view Pos => cp.pos
  def kindId: Int = getKindId(kind: cp.kind)
  def py: Int = 0
  loop py < 4 {
    def px: Int = 0
    loop px < 4 {
      if getShapeCell(
        kind: cp.kind
        rot: cp.rotation
        px: px
        py: py
      ) is 1 {
        drawRectangle(
          x: (pos.x + px).toFloat() * cellSize + offsetX
          y: (pos.y + py).toFloat() * cellSize + offsetY
          width: cellSize - 1.0
          height: cellSize - 1.0
          color: getModernColor(id: kindId)
        )
      }
      px = px + 1
    }
    py = py + 1
  }
  
  # UI Text (Modern Pastel Rainbow Palette)
  drawText(
    text: "SCORE: {g.score}"
    x: 10.0
    y: 10.0
    fontSize: 20.0
    color: { r: 255, g: 200, b: 200, a: 255 } # Soft Pink
  )
  drawText(
    text: "LEVEL: {g.level}"
    x: 10.0
    y: 35.0
    fontSize: 20.0
    color: { r: 200, g: 255, b: 200, a: 255 } # Soft Green
  )
  drawText(
    text: "LINES: {g.lines}"
    x: 10.0
    y: 60.0
    fontSize: 20.0
    color: { r: 200, g: 200, b: 255, a: 255 } # Soft Blue
  )
  
  if g.state is GameState.Paused {
    drawText(
      text: "PAUSED"
      x: 140.0
      y: 200.0
      fontSize: 40.0
      color: { r: 255, g: 255, b: 180, a: 255 } # Soft Yellow
    )
  }
  if g.state is GameState.GameOver {
    drawText(
      text: "GAME OVER"
      x: 100.0
      y: 200.0
      fontSize: 40.0
      color: { r: 255, g: 150, b: 150, a: 255 } # Soft Red
    )
    drawText(
      text: "Press R to Restart"
      x: 120.0
      y: 250.0
      fontSize: 20.0
      color: { r: 220, g: 220, b: 220, a: 255 } # Light Gray
    )
  }
  
  endDrawing()
}

func main() {
  # FLAG_WINDOW_RESIZABLE = 4
  # We can't easily use Bitwise OR yet, so just 4
  setConfigFlags(flags: 4)
  initWindow(width: 400, height: 500, title: "Rae Tetris 2D")
  setTargetFPS(fps: 60)
  
  def g: Game = {
    state: GameState.Menu
    grid: createList(initialCap: 200)
    width: 0
    height: 0
    currentPiece: {
      kind: TetrominoKind.I
      pos: {
        x: 0
        y: 0
      }
      rotation: 0
    }
    score: 0
    lines: 0
    level: 1
    moveTimer: 0
    moveDelay: 0
  }
  
  initGame(g)
  
  loop windowShouldClose() is 0 {
    # Input: Global (Menu/GameOver)
    if g.state is GameState.GameOver {
      if isKeyPressed(key: 82) is 1 { # R key
        initGame(g)
      }
    }
    
    # Input: Pause
    if isKeyPressed(key: 80) is 1 { # P key
      if g.state is GameState.Playing {
        g.state = GameState.Paused
      } else if g.state is GameState.Paused {
        g.state = GameState.Playing
      }
    }
    
    if g.state is GameState.Playing {
      def cp: mod Piece => g.currentPiece
      def pos: mod Pos => cp.pos
      
      # Left/Right
      if isKeyPressed(key: 263) is 1 {
        if canMove(g: g, dx: -1, dy: 0, dr: 0) is 1 {
          pos.x = pos.x - 1
        }
      }
      if isKeyPressed(key: 262) is 1 {
        if canMove(g: g, dx: 1, dy: 0, dr: 0) is 1 {
          pos.x = pos.x + 1
        }
      }
      
      # Rotate
      if isKeyPressed(key: 32) is 1 or isKeyPressed(key: 265) is 1 { # Space or Up
        if canMove(g: g, dx: 0, dy: 0, dr: 1) is 1 {
          cp.rotation = (cp.rotation + 1) % 4
        }
      }
      
      # Soft Drop
      def effectiveDelay: Int = g.moveDelay
      if isKeyDown(key: 264) is 1 { # Down arrow
        effectiveDelay = 2
      }
      
      # Gravity
      g.moveTimer = g.moveTimer + 1
      if g.moveTimer >= effectiveDelay {
        if canMove(g: g, dx: 0, dy: 1, dr: 0) is 1 {
          pos.y = pos.y + 1
        } else {
          lockPiece(g)
          checkLines(g)
          spawnPiece(g)
        }
        g.moveTimer = 0
      }
    }
    
    draw(g)
  }
  
  closeWindow()
}