/* Generated by Rae C backend (experimental) */
#include <stdint.h>
#include <string.h>
#include "rae_runtime.h"

typedef struct {
  RaeAny* data;
  int64_t length;
  int64_t capacity;
} List;

typedef struct {
  const char* k;
  RaeAny value;
  int8_t occupied;
} StringMapEntry;

typedef struct {
  StringMapEntry* data;
  int64_t length;
  int64_t capacity;
} StringMap;

typedef struct {
  int64_t k;
  RaeAny value;
  int8_t occupied;
} IntMapEntry;

typedef struct {
  IntMapEntry* data;
  int64_t length;
  int64_t capacity;
} IntMap;

extern int64_t rae_ext_nextTick(void);
extern int64_t rae_ext_nowMs(void);
extern int64_t rae_ext_nowNs(void);
extern void rae_ext_rae_sleep(int64_t ms);
extern double rae_ext_rae_int_to_float(int64_t i);
RAE_UNUSED static double rae_toFloat_Int_(int64_t this);
RAE_UNUSED static List rae_createList_Int_(int64_t initialCap);
RAE_UNUSED static void rae_grow_List_(List* this);
RAE_UNUSED static void rae_add_List_T_(List* this, RaeAny value);
RAE_UNUSED static RaeAny rae_get_List_Int_(List* this, int64_t index);
RAE_UNUSED static void rae_set_List_Int_T_(List* this, int64_t index, RaeAny value);
RAE_UNUSED static void rae_insert_List_Int_T_(List* this, int64_t index, RaeAny value);
RAE_UNUSED static RaeAny rae_pop_List_(List* this);
RAE_UNUSED static void rae_remove_List_Int_(List* this, int64_t index);
RAE_UNUSED static void rae_clear_List_(List* this);
RAE_UNUSED static int64_t rae_length_List_(List* this);
RAE_UNUSED static void rae_swap_List_Int_Int_(List* this, int64_t i, int64_t j);
RAE_UNUSED static void rae_free_List_(List* this);
extern int64_t rae_ext_rae_str_hash(const char* s);
extern int8_t rae_ext_rae_str_eq(const char* a, const char* b);
RAE_UNUSED static StringMap rae_createStringMap_Int_(int64_t initialCap);
RAE_UNUSED static void rae_set_StringMap_String_V_(StringMap* this, const char* k, RaeAny value);
RAE_UNUSED static RaeAny rae_get_StringMap_String_(StringMap* this, const char* k);
RAE_UNUSED static int8_t rae_has_StringMap_String_(StringMap* this, const char* k);
RAE_UNUSED static void rae_remove_StringMap_String_(StringMap* this, const char* k);
RAE_UNUSED static List rae_keys_StringMap_(StringMap* this);
RAE_UNUSED static List rae_values_StringMap_(StringMap* this);
RAE_UNUSED static void rae_growStringMap_StringMap_(StringMap* this);
RAE_UNUSED static void rae_free_StringMap_(StringMap* this);
RAE_UNUSED static IntMap rae_createIntMap_Int_(int64_t initialCap);
RAE_UNUSED static void rae_set_IntMap_Int_V_(IntMap* this, int64_t k, RaeAny value);
RAE_UNUSED static RaeAny rae_get_IntMap_Int_(IntMap* this, int64_t k);
RAE_UNUSED static int8_t rae_has_IntMap_Int_(IntMap* this, int64_t k);
RAE_UNUSED static void rae_remove_IntMap_Int_(IntMap* this, int64_t k);
RAE_UNUSED static List rae_keys_IntMap_(IntMap* this);
RAE_UNUSED static List rae_values_IntMap_(IntMap* this);
RAE_UNUSED static void rae_growIntMap_IntMap_(IntMap* this);
RAE_UNUSED static void rae_free_IntMap_(IntMap* this);
extern const char* rae_ext_rae_io_read_line(void);
extern int64_t rae_ext_rae_io_read_char(void);
RAE_UNUSED static const char* rae_readLine_(void);
RAE_UNUSED static int64_t rae_readChar_(void);
extern int64_t rae_ext_rae_str_len(const char* s);
extern int64_t rae_ext_rae_str_compare(const char* a, const char* b);
extern const char* rae_ext_rae_str_concat(const char* a, const char* b);
extern const char* rae_ext_rae_str_sub(const char* s, int64_t start, int64_t len);
extern int8_t rae_ext_rae_str_contains(const char* s, const char* sub);
extern int8_t rae_ext_rae_str_starts_with(const char* s, const char* prefix);
extern int8_t rae_ext_rae_str_ends_with(const char* s, const char* suffix);
extern int64_t rae_ext_rae_str_index_of(const char* s, const char* sub);
extern const char* rae_ext_rae_str_trim(const char* s);
extern double rae_ext_rae_str_to_f64(const char* s);
extern int64_t rae_ext_rae_str_to_i64(const char* s);
RAE_UNUSED static int64_t rae_length_String_(const char* this);
RAE_UNUSED static int64_t rae_compare_String_String_(const char* this, const char* other);
RAE_UNUSED static int8_t rae_equals_String_String_(const char* this, const char* other);
RAE_UNUSED static int64_t rae_hash_String_(const char* this);
RAE_UNUSED static const char* rae_concat_String_String_(const char* this, const char* other);
RAE_UNUSED static const char* rae_sub_String_Int_Int_(const char* this, int64_t start, int64_t len);
RAE_UNUSED static int8_t rae_contains_String_String_(const char* this, const char* sub);
RAE_UNUSED static int8_t rae_startsWith_String_String_(const char* this, const char* prefix);
RAE_UNUSED static int8_t rae_endsWith_String_String_(const char* this, const char* suffix);
RAE_UNUSED static int64_t rae_indexOf_String_String_(const char* this, const char* sub);
RAE_UNUSED static const char* rae_trim_String_(const char* this);
RAE_UNUSED static List rae_split_String_String_(const char* this, const char* sep);
RAE_UNUSED static double rae_toFloat_String_(const char* this);
RAE_UNUSED static int64_t rae_toInt_String_(const char* this);
extern void rae_ext_rae_seed(int64_t n);
extern double rae_ext_rae_random(void);
extern int64_t rae_ext_rae_random_int(int64_t min, int64_t max);
extern double rae_ext_rae_math_sin(double x);
extern double rae_ext_rae_math_cos(double x);
extern double rae_ext_rae_math_tan(double x);
extern double rae_ext_rae_math_asin(double x);
extern double rae_ext_rae_math_acos(double x);
extern double rae_ext_rae_math_atan(double x);
extern double rae_ext_rae_math_atan2(double y, double x);
extern double rae_ext_rae_math_sqrt(double x);
extern double rae_ext_rae_math_pow(double base, double exp);
extern double rae_ext_rae_math_exp(double x);
extern double rae_ext_rae_math_log(double x);
extern double rae_ext_rae_math_floor(double x);
extern double rae_ext_rae_math_ceil(double x);
extern double rae_ext_rae_math_round(double x);
RAE_UNUSED static double rae_PI_(void);
RAE_UNUSED static void rae_seed_Int_(int64_t n);
RAE_UNUSED static double rae_random_(void);
RAE_UNUSED static int64_t rae_random_Int_Int_(int64_t min, int64_t max);
RAE_UNUSED static int64_t rae_abs_Int_(int64_t n);
RAE_UNUSED static double rae_abs_Float_(double n);
RAE_UNUSED static int64_t rae_min_Int_Int_(int64_t a, int64_t b);
RAE_UNUSED static int64_t rae_max_Int_Int_(int64_t a, int64_t b);
RAE_UNUSED static int64_t rae_clamp_Int_Int_Int_(int64_t val, int64_t low, int64_t high);
RAE_UNUSED static double rae_lerp_Float_Float_Float_(double a, double b, double t);
RAE_UNUSED static double rae_randomFloat_Float_Float_(double min, double max);
RAE_UNUSED static double rae_easeLinear_Float_(double t);
RAE_UNUSED static double rae_easeInSine_Float_(double t);
RAE_UNUSED static double rae_easeOutSine_Float_(double t);
RAE_UNUSED static double rae_easeInOutSine_Float_(double t);
RAE_UNUSED static double rae_easeInQuad_Float_(double t);
RAE_UNUSED static double rae_easeOutQuad_Float_(double t);
RAE_UNUSED static double rae_easeInOutQuad_Float_(double t);
RAE_UNUSED static double rae_easeInCubic_Float_(double t);
RAE_UNUSED static double rae_easeOutCubic_Float_(double t);
RAE_UNUSED static double rae_easeInOutCubic_Float_(double t);
RAE_UNUSED static double rae_easeInQuart_Float_(double t);
RAE_UNUSED static double rae_easeOutQuart_Float_(double t);
RAE_UNUSED static double rae_easeInOutQuart_Float_(double t);
RAE_UNUSED static double rae_easeInExpo_Float_(double t);
RAE_UNUSED static double rae_easeOutExpo_Float_(double t);
RAE_UNUSED static double rae_easeInBack_Float_(double t);
RAE_UNUSED static double rae_easeOutBack_Float_(double t);
RAE_UNUSED static double rae_easeOutBounce_Float_(double t);
RAE_UNUSED static double rae_easeInBounce_Float_(double t);

RAE_UNUSED static double rae_toFloat_Int_(int64_t this) {
  return rae_ext_rae_int_to_float(this);
}

RAE_UNUSED static List rae_createList_Int_(int64_t initialCap) {
  return (List){ .data = rae_ext_rae_buf_alloc(initialCap, sizeof(RaeAny)), .length = 0, .capacity = initialCap };
}

RAE_UNUSED static void rae_grow_List_(List* this) {
  int64_t newCap = this->capacity * 2;
  if (newCap == 0) {
  newCap = 4;
  }
  RaeAny* newData = rae_ext_rae_buf_alloc(newCap, sizeof(RaeAny));
  rae_ext_rae_buf_copy(this->data, 0, newData, 0, this->length, sizeof(RaeAny));
  rae_ext_rae_buf_free(this->data);
  this->data = newData;
  this->capacity = newCap;
}

RAE_UNUSED static void rae_add_List_T_(List* this, RaeAny value) {
  if (this->length == this->capacity) {
  rae_grow_List_(this);
  }
  ((RaeAny*)(this->data))[this->length] = rae_any(value);
  this->length = this->length + 1;
}

RAE_UNUSED static RaeAny rae_get_List_Int_(List* this, int64_t index) {
  if (index < 0 || index >= this->length) {
  return rae_any_none();
  }
  return rae_any(((RaeAny*)(this->data))[index]);
}

RAE_UNUSED static void rae_set_List_Int_T_(List* this, int64_t index, RaeAny value) {
  if (index < 0 || index >= this->length) {
  return;
  }
  ((RaeAny*)(this->data))[index] = rae_any(value);
}

RAE_UNUSED static void rae_insert_List_Int_T_(List* this, int64_t index, RaeAny value) {
  if (index < 0 || index > this->length) {
  return;
  }
  if (this->length == this->capacity) {
  rae_grow_List_(this);
  }
  if (index < this->length) {
  rae_ext_rae_buf_copy(this->data, index, this->data, index + 1, this->length - index, sizeof(RaeAny));
  }
  ((RaeAny*)(this->data))[index] = rae_any(value);
  this->length = this->length + 1;
}

RAE_UNUSED static RaeAny rae_pop_List_(List* this) {
  if (this->length == 0) {
  return rae_any_none();
  }
  RaeAny val = ((RaeAny*)(this->data))[this->length - 1];
  this->length = this->length - 1;
  return rae_any(val);
}

RAE_UNUSED static void rae_remove_List_Int_(List* this, int64_t index) {
  if (index < 0 || index >= this->length) {
  return;
  }
  if (index < this->length - 1) {
  rae_ext_rae_buf_copy(this->data, index + 1, this->data, index, this->length - index - 1, sizeof(RaeAny));
  }
  this->length = this->length - 1;
}

RAE_UNUSED static void rae_clear_List_(List* this) {
  this->length = 0;
}

RAE_UNUSED static int64_t rae_length_List_(List* this) {
  return this->length;
}

RAE_UNUSED static void rae_swap_List_Int_Int_(List* this, int64_t i, int64_t j) {
  RaeAny temp = ((RaeAny*)(this->data))[i];
  ((RaeAny*)(this->data))[i] = rae_any(((RaeAny*)(this->data))[j]);
  ((RaeAny*)(this->data))[j] = rae_any(temp);
}

RAE_UNUSED static void rae_free_List_(List* this) {
  rae_ext_rae_buf_free(this->data);
  this->length = 0;
  this->capacity = 0;
}

RAE_UNUSED static StringMap rae_createStringMap_Int_(int64_t initialCap) {
  return (StringMap){ .data = rae_ext_rae_buf_alloc(initialCap, sizeof(RaeAny)), .length = 0, .capacity = initialCap };
}

RAE_UNUSED static void rae_set_StringMap_String_V_(StringMap* this, const char* k, RaeAny value) {
  if (this->capacity == 0) {
  this->capacity = 8;
  this->data = rae_ext_rae_buf_alloc(this->capacity, sizeof(RaeAny));
  }
  if (this->length * 2 > this->capacity) {
  rae_growStringMap_StringMap_(this);
  }
  int64_t h = rae_ext_rae_str_hash(k);
  int64_t idx = h % this->capacity;
  if (idx < 0) {
  idx = (-idx);
  }
  {
  while (1) {
  StringMapEntry entry = ((StringMapEntry*)(this->data))[idx];
  if ((!(entry.occupied))) {
  ((StringMapEntry*)(this->data))[idx] = (StringMapEntry){ .k = k, .value = value, .occupied = 1 };
  this->length = this->length + 1;
  return;
  }
  if (rae_ext_rae_str_eq(entry.k, k)) {
  entry.value = value;
  ((StringMapEntry*)(this->data))[idx] = entry;
  return;
  }
  idx = (idx + 1) % this->capacity;
  }
  }
}

RAE_UNUSED static RaeAny rae_get_StringMap_String_(StringMap* this, const char* k) {
  if (this->capacity == 0) {
  return rae_any_none();
  }
  int64_t h = rae_ext_rae_str_hash(k);
  int64_t idx = h % this->capacity;
  if (idx < 0) {
  idx = (-idx);
  }
  int64_t startIdx = idx;
  {
  while (1) {
  StringMapEntry entry = ((StringMapEntry*)(this->data))[idx];
  if ((!(entry.occupied))) {
  return rae_any_none();
  }
  if (rae_ext_rae_str_eq(entry.k, k)) {
  return rae_any(entry.value);
  }
  idx = (idx + 1) % this->capacity;
  if (idx == startIdx) {
  return rae_any_none();
  }
  }
  }
}

RAE_UNUSED static int8_t rae_has_StringMap_String_(StringMap* this, const char* k) {
  RaeAny __match0 = rae_any(((RaeAny)(rae_get_StringMap_String_(this, k))));
  if (__match0.type == RAE_TYPE_NONE) {
  return 0;
  } else {
  return 1;
  }
}

RAE_UNUSED static void rae_remove_StringMap_String_(StringMap* this, const char* k) {
  if (this->capacity == 0) {
  return;
  }
  int64_t h = rae_ext_rae_str_hash(k);
  int64_t idx = h % this->capacity;
  if (idx < 0) {
  idx = (-idx);
  }
  int64_t startIdx = idx;
  {
  while (1) {
  StringMapEntry entry = ((StringMapEntry*)(this->data))[idx];
  if ((!(entry.occupied))) {
  return;
  }
  if (rae_ext_rae_str_eq(entry.k, k)) {
  entry.occupied = 0;
  ((StringMapEntry*)(this->data))[idx] = entry;
  this->length = this->length - 1;
  return;
  }
  idx = (idx + 1) % this->capacity;
  if (idx == startIdx) {
  return;
  }
  }
  }
}

RAE_UNUSED static List rae_keys_StringMap_(StringMap* this) {
  List result = rae_createList_Int_(this->length);
  int64_t i = 0;
  {
  while (i < this->capacity) {
  StringMapEntry entry = ((StringMapEntry*)(this->data))[i];
  if (entry.occupied) {
  rae_add_List_T_(&(result), rae_any(entry.k));
  }
  i = i + 1;
  }
  }
  return result;
}

RAE_UNUSED static List rae_values_StringMap_(StringMap* this) {
  List result = rae_createList_Int_(this->length);
  int64_t i = 0;
  {
  while (i < this->capacity) {
  StringMapEntry entry = ((StringMapEntry*)(this->data))[i];
  if (entry.occupied) {
  rae_add_List_T_(&(result), rae_any(entry.value));
  }
  i = i + 1;
  }
  }
  return result;
}

RAE_UNUSED static void rae_growStringMap_StringMap_(StringMap* this) {
  int64_t oldCap = this->capacity;
  StringMapEntry* oldData = this->data;
  this->capacity = oldCap * 2;
  if (this->capacity == 0) {
  this->capacity = 8;
  }
  this->data = rae_ext_rae_buf_alloc(this->capacity, sizeof(RaeAny));
  this->length = 0;
  int64_t i = 0;
  {
  while (i < oldCap) {
  StringMapEntry entry = ((StringMapEntry*)(oldData))[i];
  if (entry.occupied) {
  rae_set_StringMap_String_V_(this, entry.k, rae_any(entry.value));
  }
  i = i + 1;
  }
  }
  rae_ext_rae_buf_free(oldData);
}

RAE_UNUSED static void rae_free_StringMap_(StringMap* this) {
  rae_ext_rae_buf_free(this->data);
  this->length = 0;
  this->capacity = 0;
}

RAE_UNUSED static IntMap rae_createIntMap_Int_(int64_t initialCap) {
  return (IntMap){ .data = rae_ext_rae_buf_alloc(initialCap, sizeof(RaeAny)), .length = 0, .capacity = initialCap };
}

RAE_UNUSED static void rae_set_IntMap_Int_V_(IntMap* this, int64_t k, RaeAny value) {
  if (this->capacity == 0) {
  this->capacity = 8;
  this->data = rae_ext_rae_buf_alloc(this->capacity, sizeof(RaeAny));
  }
  if (this->length * 2 > this->capacity) {
  rae_growIntMap_IntMap_(this);
  }
  int64_t h = k;
  int64_t idx = h % this->capacity;
  if (idx < 0) {
  idx = (-idx);
  }
  {
  while (1) {
  IntMapEntry entry = ((IntMapEntry*)(this->data))[idx];
  if ((!(entry.occupied))) {
  ((IntMapEntry*)(this->data))[idx] = (IntMapEntry){ .k = k, .value = value, .occupied = 1 };
  this->length = this->length + 1;
  return;
  }
  if (entry.k == k) {
  entry.value = value;
  ((IntMapEntry*)(this->data))[idx] = entry;
  return;
  }
  idx = (idx + 1) % this->capacity;
  }
  }
}

RAE_UNUSED static RaeAny rae_get_IntMap_Int_(IntMap* this, int64_t k) {
  if (this->capacity == 0) {
  return rae_any_none();
  }
  int64_t h = k;
  int64_t idx = h % this->capacity;
  if (idx < 0) {
  idx = (-idx);
  }
  int64_t startIdx = idx;
  {
  while (1) {
  IntMapEntry entry = ((IntMapEntry*)(this->data))[idx];
  if ((!(entry.occupied))) {
  return rae_any_none();
  }
  if (entry.k == k) {
  return rae_any(entry.value);
  }
  idx = (idx + 1) % this->capacity;
  if (idx == startIdx) {
  return rae_any_none();
  }
  }
  }
}

RAE_UNUSED static int8_t rae_has_IntMap_Int_(IntMap* this, int64_t k) {
  RaeAny __match0 = rae_any(((RaeAny)(rae_get_IntMap_Int_(this, k))));
  if (__match0.type == RAE_TYPE_NONE) {
  return 0;
  } else {
  return 1;
  }
}

RAE_UNUSED static void rae_remove_IntMap_Int_(IntMap* this, int64_t k) {
  if (this->capacity == 0) {
  return;
  }
  int64_t h = k;
  int64_t idx = h % this->capacity;
  if (idx < 0) {
  idx = (-idx);
  }
  int64_t startIdx = idx;
  {
  while (1) {
  IntMapEntry entry = ((IntMapEntry*)(this->data))[idx];
  if ((!(entry.occupied))) {
  return;
  }
  if (entry.k == k) {
  entry.occupied = 0;
  ((IntMapEntry*)(this->data))[idx] = entry;
  this->length = this->length - 1;
  return;
  }
  idx = (idx + 1) % this->capacity;
  if (idx == startIdx) {
  return;
  }
  }
  }
}

RAE_UNUSED static List rae_keys_IntMap_(IntMap* this) {
  List result = rae_createList_Int_(this->length);
  int64_t i = 0;
  {
  while (i < this->capacity) {
  IntMapEntry entry = ((IntMapEntry*)(this->data))[i];
  if (entry.occupied) {
  rae_add_List_T_(&(result), rae_any(entry.k));
  }
  i = i + 1;
  }
  }
  return result;
}

RAE_UNUSED static List rae_values_IntMap_(IntMap* this) {
  List result = rae_createList_Int_(this->length);
  int64_t i = 0;
  {
  while (i < this->capacity) {
  IntMapEntry entry = ((IntMapEntry*)(this->data))[i];
  if (entry.occupied) {
  rae_add_List_T_(&(result), rae_any(entry.value));
  }
  i = i + 1;
  }
  }
  return result;
}

RAE_UNUSED static void rae_growIntMap_IntMap_(IntMap* this) {
  int64_t oldCap = this->capacity;
  IntMapEntry* oldData = this->data;
  this->capacity = oldCap * 2;
  if (this->capacity == 0) {
  this->capacity = 8;
  }
  this->data = rae_ext_rae_buf_alloc(this->capacity, sizeof(RaeAny));
  this->length = 0;
  int64_t i = 0;
  {
  while (i < oldCap) {
  IntMapEntry entry = ((IntMapEntry*)(oldData))[i];
  if (entry.occupied) {
  rae_set_IntMap_Int_V_(this, entry.k, rae_any(entry.value));
  }
  i = i + 1;
  }
  }
  rae_ext_rae_buf_free(oldData);
}

RAE_UNUSED static void rae_free_IntMap_(IntMap* this) {
  rae_ext_rae_buf_free(this->data);
  this->length = 0;
  this->capacity = 0;
}

RAE_UNUSED static const char* rae_readLine_(void) {
  return rae_ext_rae_io_read_line();
}

RAE_UNUSED static int64_t rae_readChar_(void) {
  return rae_ext_rae_io_read_char();
}

RAE_UNUSED static int64_t rae_length_String_(const char* this) {
  return rae_ext_rae_str_len(this);
}

RAE_UNUSED static int64_t rae_compare_String_String_(const char* this, const char* other) {
  return rae_ext_rae_str_compare(this, other);
}

RAE_UNUSED static int8_t rae_equals_String_String_(const char* this, const char* other) {
  return rae_ext_rae_str_eq(this, other);
}

RAE_UNUSED static int64_t rae_hash_String_(const char* this) {
  return rae_ext_rae_str_hash(this);
}

RAE_UNUSED static const char* rae_concat_String_String_(const char* this, const char* other) {
  return rae_ext_rae_str_concat(this, other);
}

RAE_UNUSED static const char* rae_sub_String_Int_Int_(const char* this, int64_t start, int64_t len) {
  return rae_ext_rae_str_sub(this, start, len);
}

RAE_UNUSED static int8_t rae_contains_String_String_(const char* this, const char* sub) {
  return rae_ext_rae_str_contains(this, sub);
}

RAE_UNUSED static int8_t rae_startsWith_String_String_(const char* this, const char* prefix) {
  return rae_ext_rae_str_starts_with(this, prefix);
}

RAE_UNUSED static int8_t rae_endsWith_String_String_(const char* this, const char* suffix) {
  return rae_ext_rae_str_ends_with(this, suffix);
}

RAE_UNUSED static int64_t rae_indexOf_String_String_(const char* this, const char* sub) {
  return rae_ext_rae_str_index_of(this, sub);
}

RAE_UNUSED static const char* rae_trim_String_(const char* this) {
  return rae_ext_rae_str_trim(this);
}

RAE_UNUSED static List rae_split_String_String_(const char* this, const char* sep) {
  List result = rae_createList_Int_(4);
  if (rae_length_String_(sep) == 0) {
  rae_add_List_T_(&(result), rae_any(this));
  return result;
  }
  const char* remaining = this;
  {
  while (1) {
  int64_t idx = rae_indexOf_String_String_(remaining, sep);
  if (idx == (-1)) {
  rae_add_List_T_(&(result), rae_any(remaining));
  return result;
  }
  const char* part = rae_sub_String_Int_Int_(remaining, 0, idx);
  rae_add_List_T_(&(result), rae_any(part));
  remaining = rae_sub_String_Int_Int_(remaining, idx + rae_length_String_(sep), rae_length_String_(remaining) - idx - rae_length_String_(sep));
  }
  }
  return result;
}

RAE_UNUSED static double rae_toFloat_String_(const char* this) {
  return rae_ext_rae_str_to_f64(this);
}

RAE_UNUSED static int64_t rae_toInt_String_(const char* this) {
  return rae_ext_rae_str_to_i64(this);
}

RAE_UNUSED static double rae_PI_(void) {
  return 3.14159265358979323846;
}

RAE_UNUSED static void rae_seed_Int_(int64_t n) {
  rae_ext_rae_seed(n);
}

RAE_UNUSED static double rae_random_(void) {
  return rae_ext_rae_random();
}

RAE_UNUSED static int64_t rae_random_Int_Int_(int64_t min, int64_t max) {
  return rae_ext_rae_random_int(min, max);
}

RAE_UNUSED static int64_t rae_abs_Int_(int64_t n) {
  if (n < 0) {
  return (-n);
  }
  return n;
}

RAE_UNUSED static double rae_abs_Float_(double n) {
  if (n < 0.0) {
  return (-n);
  }
  return n;
}

RAE_UNUSED static int64_t rae_min_Int_Int_(int64_t a, int64_t b) {
  if (a < b) {
  return a;
  }
  return b;
}

RAE_UNUSED static int64_t rae_max_Int_Int_(int64_t a, int64_t b) {
  if (a > b) {
  return a;
  }
  return b;
}

RAE_UNUSED static int64_t rae_clamp_Int_Int_Int_(int64_t val, int64_t low, int64_t high) {
  if (val < low) {
  return low;
  }
  if (val > high) {
  return high;
  }
  return val;
}

RAE_UNUSED static double rae_lerp_Float_Float_Float_(double a, double b, double t) {
  return a + (b - a) * t;
}

RAE_UNUSED static double rae_randomFloat_Float_Float_(double min, double max) {
  return min + rae_ext_rae_random() * (max - min);
}

RAE_UNUSED static double rae_easeLinear_Float_(double t) {
  return t;
}

RAE_UNUSED static double rae_easeInSine_Float_(double t) {
  return 1.0 - rae_ext_rae_math_cos(t * rae_PI_() / 2.0);
}

RAE_UNUSED static double rae_easeOutSine_Float_(double t) {
  return rae_ext_rae_math_sin(t * rae_PI_() / 2.0);
}

RAE_UNUSED static double rae_easeInOutSine_Float_(double t) {
  return (-(rae_ext_rae_math_cos(rae_PI_() * t) - 1.0)) / 2.0;
}

RAE_UNUSED static double rae_easeInQuad_Float_(double t) {
  return t * t;
}

RAE_UNUSED static double rae_easeOutQuad_Float_(double t) {
  return 1.0 - (1.0 - t) * (1.0 - t);
}

RAE_UNUSED static double rae_easeInOutQuad_Float_(double t) {
  if (t < 0.5) {
  return 2.0 * t * t;
  }
  return 1.0 - rae_ext_rae_math_pow((-2.0) * t + 2.0, 2.0) / 2.0;
}

RAE_UNUSED static double rae_easeInCubic_Float_(double t) {
  return t * t * t;
}

RAE_UNUSED static double rae_easeOutCubic_Float_(double t) {
  return 1.0 - rae_ext_rae_math_pow(1.0 - t, 3.0);
}

RAE_UNUSED static double rae_easeInOutCubic_Float_(double t) {
  if (t < 0.5) {
  return 4.0 * t * t * t;
  }
  return 1.0 - rae_ext_rae_math_pow((-2.0) * t + 2.0, 3.0) / 2.0;
}

RAE_UNUSED static double rae_easeInQuart_Float_(double t) {
  return t * t * t * t;
}

RAE_UNUSED static double rae_easeOutQuart_Float_(double t) {
  return 1.0 - rae_ext_rae_math_pow(1.0 - t, 4.0);
}

RAE_UNUSED static double rae_easeInOutQuart_Float_(double t) {
  if (t < 0.5) {
  return 8.0 * t * t * t * t;
  }
  return 1.0 - rae_ext_rae_math_pow((-2.0) * t + 2.0, 4.0) / 2.0;
}

RAE_UNUSED static double rae_easeInExpo_Float_(double t) {
  if (t == 0.0) {
  return 0.0;
  }
  return rae_ext_rae_math_pow(2.0, 10.0 * t - 10.0);
}

RAE_UNUSED static double rae_easeOutExpo_Float_(double t) {
  if (t == 1.0) {
  return 1.0;
  }
  return 1.0 - rae_ext_rae_math_pow(2.0, (-10.0) * t);
}

RAE_UNUSED static double rae_easeInBack_Float_(double t) {
  double c1 = 1.70158;
  double c3 = c1 + 1.0;
  return c3 * t * t * t - c1 * t * t;
}

RAE_UNUSED static double rae_easeOutBack_Float_(double t) {
  double c1 = 1.70158;
  double c3 = c1 + 1.0;
  return 1.0 + c3 * rae_ext_rae_math_pow(t - 1.0, 3.0) + c1 * rae_ext_rae_math_pow(t - 1.0, 2.0);
}

RAE_UNUSED static double rae_easeOutBounce_Float_(double t) {
  double n1 = 7.5625;
  double d1 = 2.75;
  if (t < 1.0 / d1) {
  return n1 * t * t;
  } else {
  if (t < 2.0 / d1) {
  t = t - 1.5 / d1;
  return n1 * t * t + 0.75;
  } else {
  if (t < 2.5 / d1) {
  t = t - 2.25 / d1;
  return n1 * t * t + 0.9375;
  } else {
  t = t - 2.625 / d1;
  return n1 * t * t + 0.984375;
  }
  }
  }
}

RAE_UNUSED static double rae_easeInBounce_Float_(double t) {
  return 1.0 - rae_easeOutBounce_Float_(1.0 - t);
}

int main(void) {
  rae_ext_rae_log_cstr("Easing Demo (t from 0.0 to 1.0):");
  int64_t i = 0;
  {
  while (i <= 10) {
  double t = rae_toFloat_Int_(i) / 10.0;
  double linear = rae_easeLinear_Float_(t);
  double sineIn = rae_easeInSine_Float_(t);
  double quadOut = rae_easeOutQuad_Float_(t);
  double bounceOut = rae_easeOutBounce_Float_(t);
  rae_ext_rae_log_cstr(rae_ext_rae_str_concat(rae_ext_rae_str_concat(rae_ext_rae_str_concat(rae_ext_rae_str_concat(rae_ext_rae_str_concat(rae_ext_rae_str_concat(rae_ext_rae_str_concat(rae_ext_rae_str_concat(rae_ext_rae_str_concat(rae_ext_rae_str_concat("t: ", rae_ext_rae_str(t)), " -> Linear: "), rae_ext_rae_str(linear)), ", SineIn: "), rae_ext_rae_str(sineIn)), ", QuadOut: "), rae_ext_rae_str(quadOut)), ", BounceOut: "), rae_ext_rae_str(bounceOut)), ""));
  i = i + 1;
  }
  }
  return 0;
}

