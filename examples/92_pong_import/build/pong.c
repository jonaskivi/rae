/* Generated by Rae C backend (experimental) */
#include <stdint.h>
#include <string.h>
#include "rae_runtime.h"

typedef struct {
  int64_t state;
  int64_t timer;
  double targetY;
  int64_t decision;
} AIState;

typedef struct {
  double x;
  double y;
} Transform;

typedef struct {
  double dx;
  double dy;
} Velocity;

extern int64_t nextTick(void);
extern void sleepMs(int64_t ms);
extern RaeList* rae_list_create(int64_t cap);
extern void rae_list_add(RaeList* list, int64_t value);
extern int64_t rae_list_get(RaeList* list, int64_t index);
extern int64_t rae_list_length(RaeList* list);
extern void rae_seed(int64_t n);
extern double rae_random(void);
extern int64_t rae_random_int(int64_t min, int64_t max);
RAE_UNUSED static void seed(int64_t n);
RAE_UNUSED static double random(void);
RAE_UNUSED static int64_t randomInt(int64_t min, int64_t max);
extern void initWindow(int64_t width, int64_t height, const char* title);
extern int64_t windowShouldClose(void);
extern void closeWindow(void);
extern void beginDrawing(void);
extern void endDrawing(void);
extern void clearBackground(int64_t r, int64_t g, int64_t b, int64_t a);
extern void drawRectangle(double x, double y, double width, double height, int64_t r, int64_t g, int64_t b, int64_t a);
extern void drawCircle(double x, double y, double radius, int64_t r, int64_t g, int64_t b, int64_t a);
extern void drawText(const char* text, double x, double y, double fontSize, int64_t r, int64_t g, int64_t b, int64_t a);
extern void setTargetFPS(int64_t fps);
extern int64_t isKeyDown(int64_t key);
RAE_UNUSED static double paddleAiSystem(AIState* ai, double ballY, double paddleY);
RAE_UNUSED static void movementSystem(Transform* pos, Velocity* vel);
RAE_UNUSED static void bounceSystem(Transform* pos, Velocity* vel, double radius, double height);
RAE_UNUSED static void paddleCollisionSystem(Transform* bPos, Velocity* bVel, Transform* pPos, double pWidth, double pHeight, int64_t isLeft);
RAE_UNUSED static void paddleInputSystem(Transform* pos, double speed, double height, double pHeight);
RAE_UNUSED static void drawUISystem(int64_t p1Score, int64_t p2Score, int64_t winner);

RAE_UNUSED static void seed(int64_t n) {
  rae_seed(n);
}

RAE_UNUSED static double random(void) {
  return rae_random();
}

RAE_UNUSED static int64_t randomInt(int64_t min, int64_t max) {
  return rae_random_int(min, max);
}

RAE_UNUSED static double paddleAiSystem(AIState* ai, double ballY, double paddleY) {
  double newY = paddleY;
  if (ai->state == 0) {
  ai->timer = ai->timer + 1;
  if (ai->timer > 12 + randomInt(0, 6)) {
  ai->targetY = ballY;
  ai->timer = 0;
  ai->state = 1;
  }
  }
  if (ai->state == 1) {
  if (ai->targetY < paddleY + 40.0) {
  ai->decision = 1;
  ai->timer = randomInt(50, 150);
  ai->state = 2;
  } else {
  if (ai->targetY > paddleY + 60.0) {
  ai->decision = 2;
  ai->timer = randomInt(5, 15);
  ai->state = 2;
  } else {
  ai->decision = 0;
  ai->timer = randomInt(5, 10);
  ai->state = 3;
  }
  }
  }
  if (ai->state == 2) {
  if (ai->decision == 1) {
  newY = newY - 4.5;
  }
  if (ai->decision == 2) {
  newY = newY + 4.5;
  }
  ai->timer = ai->timer - 1;
  if (ai->timer <= 0) {
  ai->state = 3;
  ai->timer = randomInt(5, 10);
  }
  }
  if (ai->state == 3) {
  ai->timer = ai->timer - 1;
  if (ai->timer <= 0) {
  ai->state = 0;
  ai->timer = 0;
  }
  }
  if (newY < 0.0) {
  newY = 0.0;
  }
  if (newY > 350.0) {
  newY = 350.0;
  }
  return newY;
}

RAE_UNUSED static void movementSystem(Transform* pos, Velocity* vel) {
  pos->x = pos->x + vel->dx;
  pos->y = pos->y + vel->dy;
}

RAE_UNUSED static void bounceSystem(Transform* pos, Velocity* vel, double radius, double height) {
  if (pos->y < radius) {
  vel->dy = 4.0;
  }
  if (pos->y > height - radius) {
  vel->dy = (-4.0);
  }
}

RAE_UNUSED static void paddleCollisionSystem(Transform* bPos, Velocity* bVel, Transform* pPos, double pWidth, double pHeight, int64_t isLeft) {
  if (isLeft == 1) {
  if (bPos->x - 10.0 < pPos->x + pWidth) {
  if (bPos->y > pPos->y) {
  if (bPos->y < pPos->y + pHeight) {
  if (bVel->dx < 0.0) {
  bVel->dx = (-bVel->dx) + 1.2;
  }
  }
  }
  }
  } else {
  if (bPos->x + 10.0 > pPos->x) {
  if (bPos->y > pPos->y) {
  if (bPos->y < pPos->y + pHeight) {
  if (bVel->dx > 0.0) {
  bVel->dx = (-bVel->dx) - 1.2;
  }
  }
  }
  }
  }
}

RAE_UNUSED static void paddleInputSystem(Transform* pos, double speed, double height, double pHeight) {
  if (isKeyDown(87) == 1) {
  pos->y = pos->y - speed;
  }
  if (isKeyDown(265) == 1) {
  pos->y = pos->y - speed;
  }
  if (isKeyDown(83) == 1) {
  pos->y = pos->y + speed;
  }
  if (isKeyDown(264) == 1) {
  pos->y = pos->y + speed;
  }
  if (pos->y < 0.0) {
  pos->y = 0.0;
  }
  if (pos->y > height - pHeight) {
  pos->y = height - pHeight;
  }
}

RAE_UNUSED static void drawUISystem(int64_t p1Score, int64_t p2Score, int64_t winner) {
  if (winner <= 0) {
  drawText(rae_str_concat(rae_str_concat(rae_str_concat(rae_str_concat("", rae_str(p1Score)), " - "), rae_str(p2Score)), ""), 350.0, 20.0, 40.0, 255, 145, 0, 255);
  }
  if (winner == 1) {
  drawText("YOU WIN", 350.0, 200.0, 40.0, 255, 145, 0, 255);
  }
  if (winner == 2) {
  drawText("CPU WINS", 350.0, 200.0, 40.0, 255, 145, 0, 255);
  }
}

int main(void) {
  initWindow(800, 450, "Rae Advanced Pong (ECS)");
  setTargetFPS(60);
  Transform p1Pos = { .x = 20.0, .y = 175.0 };
  Transform p2Pos = { .x = 760.0, .y = 175.0 };
  Transform bPos = { .x = 400.0, .y = 225.0 };
  Velocity bVel = { .dx = 4.0, .dy = 4.0 };
  AIState aiState = { .state = 0, .timer = 0, .targetY = 225.0, .decision = 0 };
  int64_t p1Score = 0;
  int64_t p2Score = 0;
  int64_t scoreToWinMatch = 3;
  int64_t winner = 0;
  {
  while (windowShouldClose() == 0) {
  paddleInputSystem(&p1Pos, 5.0, 450.0, 100.0);
  p2Pos.y = paddleAiSystem(&aiState, bPos.y, p2Pos.y);
  movementSystem(&bPos, &bVel);
  bounceSystem(&bPos, &bVel, 10.0, 450.0);
  paddleCollisionSystem(&bPos, &bVel, &p1Pos, 20.0, 100.0, 1);
  paddleCollisionSystem(&bPos, &bVel, &p2Pos, 20.0, 100.0, 0);
  if (bPos.x < 0.0) {
  p2Score = p2Score + 1;
  bPos.x = 400.0;
  bPos.y = 225.0;
  bVel.dx = 4.0;
  }
  if (bPos.x > 800.0) {
  p1Score = p1Score + 1;
  bPos.x = 400.0;
  bPos.y = 225.0;
  bVel.dx = (-4.0);
  }
  if (p1Score == scoreToWinMatch) {
  winner = 1;
  }
  if (p2Score == scoreToWinMatch) {
  winner = 2;
  }
  beginDrawing();
  clearBackground(20, 20, 20, 255);
  drawUISystem(p1Score, p2Score, winner);
  drawRectangle(20.0, p1Pos.y, 20.0, 100.0, 255, 255, 255, 255);
  drawRectangle(760.0, p2Pos.y, 20.0, 100.0, 255, 255, 255, 255);
  drawCircle(bPos.x, bPos.y, 10.0, 255, 255, 255, 255);
  endDrawing();
  }
  }
  closeWindow();
  return 0;
}

