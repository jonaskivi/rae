type Velocity {
  dx: Float
  dy: Float
}

type Entity {
  pos: Point
  vel: opt Velocity
}

# Optional value, self-contained
type Point {
  x: Float
  y: Float
}

func updatePosition(p: mod Point, v: Velocity) {
  p.x = p.x + v.dx
  p.y = p.y + v.dy
}

func main() {
  # 1. Copy semantics (=)
  def v1: Velocity = { dx: 1.0, dy: 1.0 }
  # Deep copy
  def v2: Velocity = v1
  v2.dx = 2.0
  # 2. Binding semantics (=>)
  log("v1.dx (should be 1.0):")
  log(v1.dx)
  log("v2.dx (should be 2.0):")
  log(v2.dx)
  def p: Point = { x: 0.0, y: 0.0 }
  # Mutable binding
  def pRef: mod Point => p
  pRef.x = 10.0
  # 3. Complex types: opt mod
  log("p.x after pRef modification (should be 10.0):")
  log(p.x)
  def target: Point = { x: 5.0, y: 5.0 }
  def selected: opt mod Point => target
  match selected {
    default {
      log("Selected point exists, moving it...")
      updatePosition(p: selected, v: v1)
    }
  }
  log("target.x after update (should be 6.0):")
  log(target.x)
}


